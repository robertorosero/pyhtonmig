/* File automatically generated by ../Parser/asdl_c.py */

#include "Python.h"
#include "Python-ast.h"

mod_ty
Module(asdl_seq * body)
{
        mod_ty p;
        p = (mod_ty)malloc(sizeof(*p));
        if (!p) {
                PyErr_SetString(PyExc_MemoryError, "no memory");
                return NULL;
        }
        p->kind = Module_kind;
        p->v.Module.body = body;
        return p;
}

mod_ty
Interactive(stmt_ty body)
{
        mod_ty p;
        if (!body) {
                PyErr_SetString(PyExc_ValueError,
                                "field body is required for Interactive");
                return NULL;
        }
        p = (mod_ty)malloc(sizeof(*p));
        if (!p) {
                PyErr_SetString(PyExc_MemoryError, "no memory");
                return NULL;
        }
        p->kind = Interactive_kind;
        p->v.Interactive.body = body;
        return p;
}

mod_ty
Expression(expr_ty body)
{
        mod_ty p;
        if (!body) {
                PyErr_SetString(PyExc_ValueError,
                                "field body is required for Expression");
                return NULL;
        }
        p = (mod_ty)malloc(sizeof(*p));
        if (!p) {
                PyErr_SetString(PyExc_MemoryError, "no memory");
                return NULL;
        }
        p->kind = Expression_kind;
        p->v.Expression.body = body;
        return p;
}

mod_ty
Suite(asdl_seq * body)
{
        mod_ty p;
        p = (mod_ty)malloc(sizeof(*p));
        if (!p) {
                PyErr_SetString(PyExc_MemoryError, "no memory");
                return NULL;
        }
        p->kind = Suite_kind;
        p->v.Suite.body = body;
        return p;
}

stmt_ty
FunctionDef(identifier name, arguments_ty args, asdl_seq * body, int lineno)
{
        stmt_ty p;
        if (!name) {
                PyErr_SetString(PyExc_ValueError,
                                "field name is required for FunctionDef");
                return NULL;
        }
        if (!args) {
                PyErr_SetString(PyExc_ValueError,
                                "field args is required for FunctionDef");
                return NULL;
        }
        p = (stmt_ty)malloc(sizeof(*p));
        if (!p) {
                PyErr_SetString(PyExc_MemoryError, "no memory");
                return NULL;
        }
        p->kind = FunctionDef_kind;
        p->v.FunctionDef.name = name;
        p->v.FunctionDef.args = args;
        p->v.FunctionDef.body = body;
        p->lineno = lineno;
        return p;
}

stmt_ty
ClassDef(identifier name, asdl_seq * bases, asdl_seq * body, int lineno)
{
        stmt_ty p;
        if (!name) {
                PyErr_SetString(PyExc_ValueError,
                                "field name is required for ClassDef");
                return NULL;
        }
        p = (stmt_ty)malloc(sizeof(*p));
        if (!p) {
                PyErr_SetString(PyExc_MemoryError, "no memory");
                return NULL;
        }
        p->kind = ClassDef_kind;
        p->v.ClassDef.name = name;
        p->v.ClassDef.bases = bases;
        p->v.ClassDef.body = body;
        p->lineno = lineno;
        return p;
}

stmt_ty
Return(expr_ty value, int lineno)
{
        stmt_ty p;
        p = (stmt_ty)malloc(sizeof(*p));
        if (!p) {
                PyErr_SetString(PyExc_MemoryError, "no memory");
                return NULL;
        }
        p->kind = Return_kind;
        p->v.Return.value = value;
        p->lineno = lineno;
        return p;
}

stmt_ty
Yield(expr_ty value, int lineno)
{
        stmt_ty p;
        if (!value) {
                PyErr_SetString(PyExc_ValueError,
                                "field value is required for Yield");
                return NULL;
        }
        p = (stmt_ty)malloc(sizeof(*p));
        if (!p) {
                PyErr_SetString(PyExc_MemoryError, "no memory");
                return NULL;
        }
        p->kind = Yield_kind;
        p->v.Yield.value = value;
        p->lineno = lineno;
        return p;
}

stmt_ty
Delete(asdl_seq * targets, int lineno)
{
        stmt_ty p;
        p = (stmt_ty)malloc(sizeof(*p));
        if (!p) {
                PyErr_SetString(PyExc_MemoryError, "no memory");
                return NULL;
        }
        p->kind = Delete_kind;
        p->v.Delete.targets = targets;
        p->lineno = lineno;
        return p;
}

stmt_ty
Assign(asdl_seq * targets, expr_ty value, int lineno)
{
        stmt_ty p;
        if (!value) {
                PyErr_SetString(PyExc_ValueError,
                                "field value is required for Assign");
                return NULL;
        }
        p = (stmt_ty)malloc(sizeof(*p));
        if (!p) {
                PyErr_SetString(PyExc_MemoryError, "no memory");
                return NULL;
        }
        p->kind = Assign_kind;
        p->v.Assign.targets = targets;
        p->v.Assign.value = value;
        p->lineno = lineno;
        return p;
}

stmt_ty
AugAssign(expr_ty target, operator_ty op, expr_ty value, int lineno)
{
        stmt_ty p;
        if (!target) {
                PyErr_SetString(PyExc_ValueError,
                                "field target is required for AugAssign");
                return NULL;
        }
        if (!op) {
                PyErr_SetString(PyExc_ValueError,
                                "field op is required for AugAssign");
                return NULL;
        }
        if (!value) {
                PyErr_SetString(PyExc_ValueError,
                                "field value is required for AugAssign");
                return NULL;
        }
        p = (stmt_ty)malloc(sizeof(*p));
        if (!p) {
                PyErr_SetString(PyExc_MemoryError, "no memory");
                return NULL;
        }
        p->kind = AugAssign_kind;
        p->v.AugAssign.target = target;
        p->v.AugAssign.op = op;
        p->v.AugAssign.value = value;
        p->lineno = lineno;
        return p;
}

stmt_ty
Print(expr_ty dest, asdl_seq * values, bool nl, int lineno)
{
        stmt_ty p;
        p = (stmt_ty)malloc(sizeof(*p));
        if (!p) {
                PyErr_SetString(PyExc_MemoryError, "no memory");
                return NULL;
        }
        p->kind = Print_kind;
        p->v.Print.dest = dest;
        p->v.Print.values = values;
        p->v.Print.nl = nl;
        p->lineno = lineno;
        return p;
}

stmt_ty
For(expr_ty target, expr_ty iter, asdl_seq * body, asdl_seq * orelse, int
    lineno)
{
        stmt_ty p;
        if (!target) {
                PyErr_SetString(PyExc_ValueError,
                                "field target is required for For");
                return NULL;
        }
        if (!iter) {
                PyErr_SetString(PyExc_ValueError,
                                "field iter is required for For");
                return NULL;
        }
        p = (stmt_ty)malloc(sizeof(*p));
        if (!p) {
                PyErr_SetString(PyExc_MemoryError, "no memory");
                return NULL;
        }
        p->kind = For_kind;
        p->v.For.target = target;
        p->v.For.iter = iter;
        p->v.For.body = body;
        p->v.For.orelse = orelse;
        p->lineno = lineno;
        return p;
}

stmt_ty
While(expr_ty test, asdl_seq * body, asdl_seq * orelse, int lineno)
{
        stmt_ty p;
        if (!test) {
                PyErr_SetString(PyExc_ValueError,
                                "field test is required for While");
                return NULL;
        }
        p = (stmt_ty)malloc(sizeof(*p));
        if (!p) {
                PyErr_SetString(PyExc_MemoryError, "no memory");
                return NULL;
        }
        p->kind = While_kind;
        p->v.While.test = test;
        p->v.While.body = body;
        p->v.While.orelse = orelse;
        p->lineno = lineno;
        return p;
}

stmt_ty
If(expr_ty test, asdl_seq * body, asdl_seq * orelse, int lineno)
{
        stmt_ty p;
        if (!test) {
                PyErr_SetString(PyExc_ValueError,
                                "field test is required for If");
                return NULL;
        }
        p = (stmt_ty)malloc(sizeof(*p));
        if (!p) {
                PyErr_SetString(PyExc_MemoryError, "no memory");
                return NULL;
        }
        p->kind = If_kind;
        p->v.If.test = test;
        p->v.If.body = body;
        p->v.If.orelse = orelse;
        p->lineno = lineno;
        return p;
}

stmt_ty
Raise(expr_ty type, expr_ty inst, expr_ty tback, int lineno)
{
        stmt_ty p;
        p = (stmt_ty)malloc(sizeof(*p));
        if (!p) {
                PyErr_SetString(PyExc_MemoryError, "no memory");
                return NULL;
        }
        p->kind = Raise_kind;
        p->v.Raise.type = type;
        p->v.Raise.inst = inst;
        p->v.Raise.tback = tback;
        p->lineno = lineno;
        return p;
}

stmt_ty
TryExcept(asdl_seq * body, asdl_seq * handlers, asdl_seq * orelse, int
          lineno)
{
        stmt_ty p;
        p = (stmt_ty)malloc(sizeof(*p));
        if (!p) {
                PyErr_SetString(PyExc_MemoryError, "no memory");
                return NULL;
        }
        p->kind = TryExcept_kind;
        p->v.TryExcept.body = body;
        p->v.TryExcept.handlers = handlers;
        p->v.TryExcept.orelse = orelse;
        p->lineno = lineno;
        return p;
}

stmt_ty
TryFinally(asdl_seq * body, asdl_seq * finalbody, int lineno)
{
        stmt_ty p;
        p = (stmt_ty)malloc(sizeof(*p));
        if (!p) {
                PyErr_SetString(PyExc_MemoryError, "no memory");
                return NULL;
        }
        p->kind = TryFinally_kind;
        p->v.TryFinally.body = body;
        p->v.TryFinally.finalbody = finalbody;
        p->lineno = lineno;
        return p;
}

stmt_ty
Assert(expr_ty test, expr_ty msg, int lineno)
{
        stmt_ty p;
        if (!test) {
                PyErr_SetString(PyExc_ValueError,
                                "field test is required for Assert");
                return NULL;
        }
        p = (stmt_ty)malloc(sizeof(*p));
        if (!p) {
                PyErr_SetString(PyExc_MemoryError, "no memory");
                return NULL;
        }
        p->kind = Assert_kind;
        p->v.Assert.test = test;
        p->v.Assert.msg = msg;
        p->lineno = lineno;
        return p;
}

stmt_ty
Import(asdl_seq * names, int lineno)
{
        stmt_ty p;
        p = (stmt_ty)malloc(sizeof(*p));
        if (!p) {
                PyErr_SetString(PyExc_MemoryError, "no memory");
                return NULL;
        }
        p->kind = Import_kind;
        p->v.Import.names = names;
        p->lineno = lineno;
        return p;
}

stmt_ty
ImportFrom(identifier module, asdl_seq * names, int lineno)
{
        stmt_ty p;
        if (!module) {
                PyErr_SetString(PyExc_ValueError,
                                "field module is required for ImportFrom");
                return NULL;
        }
        p = (stmt_ty)malloc(sizeof(*p));
        if (!p) {
                PyErr_SetString(PyExc_MemoryError, "no memory");
                return NULL;
        }
        p->kind = ImportFrom_kind;
        p->v.ImportFrom.module = module;
        p->v.ImportFrom.names = names;
        p->lineno = lineno;
        return p;
}

stmt_ty
Exec(expr_ty body, expr_ty globals, expr_ty locals, int lineno)
{
        stmt_ty p;
        if (!body) {
                PyErr_SetString(PyExc_ValueError,
                                "field body is required for Exec");
                return NULL;
        }
        p = (stmt_ty)malloc(sizeof(*p));
        if (!p) {
                PyErr_SetString(PyExc_MemoryError, "no memory");
                return NULL;
        }
        p->kind = Exec_kind;
        p->v.Exec.body = body;
        p->v.Exec.globals = globals;
        p->v.Exec.locals = locals;
        p->lineno = lineno;
        return p;
}

stmt_ty
Global(asdl_seq * names, int lineno)
{
        stmt_ty p;
        p = (stmt_ty)malloc(sizeof(*p));
        if (!p) {
                PyErr_SetString(PyExc_MemoryError, "no memory");
                return NULL;
        }
        p->kind = Global_kind;
        p->v.Global.names = names;
        p->lineno = lineno;
        return p;
}

stmt_ty
Expr(expr_ty value, int lineno)
{
        stmt_ty p;
        if (!value) {
                PyErr_SetString(PyExc_ValueError,
                                "field value is required for Expr");
                return NULL;
        }
        p = (stmt_ty)malloc(sizeof(*p));
        if (!p) {
                PyErr_SetString(PyExc_MemoryError, "no memory");
                return NULL;
        }
        p->kind = Expr_kind;
        p->v.Expr.value = value;
        p->lineno = lineno;
        return p;
}

stmt_ty
Pass(int lineno)
{
        stmt_ty p;
        p = (stmt_ty)malloc(sizeof(*p));
        if (!p) {
                PyErr_SetString(PyExc_MemoryError, "no memory");
                return NULL;
        }
        p->kind = Pass_kind;
        p->lineno = lineno;
        return p;
}

stmt_ty
Break(int lineno)
{
        stmt_ty p;
        p = (stmt_ty)malloc(sizeof(*p));
        if (!p) {
                PyErr_SetString(PyExc_MemoryError, "no memory");
                return NULL;
        }
        p->kind = Break_kind;
        p->lineno = lineno;
        return p;
}

stmt_ty
Continue(int lineno)
{
        stmt_ty p;
        p = (stmt_ty)malloc(sizeof(*p));
        if (!p) {
                PyErr_SetString(PyExc_MemoryError, "no memory");
                return NULL;
        }
        p->kind = Continue_kind;
        p->lineno = lineno;
        return p;
}

expr_ty
BoolOp(boolop_ty op, asdl_seq * values)
{
        expr_ty p;
        if (!op) {
                PyErr_SetString(PyExc_ValueError,
                                "field op is required for BoolOp");
                return NULL;
        }
        p = (expr_ty)malloc(sizeof(*p));
        if (!p) {
                PyErr_SetString(PyExc_MemoryError, "no memory");
                return NULL;
        }
        p->kind = BoolOp_kind;
        p->v.BoolOp.op = op;
        p->v.BoolOp.values = values;
        return p;
}

expr_ty
BinOp(expr_ty left, operator_ty op, expr_ty right)
{
        expr_ty p;
        if (!left) {
                PyErr_SetString(PyExc_ValueError,
                                "field left is required for BinOp");
                return NULL;
        }
        if (!op) {
                PyErr_SetString(PyExc_ValueError,
                                "field op is required for BinOp");
                return NULL;
        }
        if (!right) {
                PyErr_SetString(PyExc_ValueError,
                                "field right is required for BinOp");
                return NULL;
        }
        p = (expr_ty)malloc(sizeof(*p));
        if (!p) {
                PyErr_SetString(PyExc_MemoryError, "no memory");
                return NULL;
        }
        p->kind = BinOp_kind;
        p->v.BinOp.left = left;
        p->v.BinOp.op = op;
        p->v.BinOp.right = right;
        return p;
}

expr_ty
UnaryOp(unaryop_ty op, expr_ty operand)
{
        expr_ty p;
        if (!op) {
                PyErr_SetString(PyExc_ValueError,
                                "field op is required for UnaryOp");
                return NULL;
        }
        if (!operand) {
                PyErr_SetString(PyExc_ValueError,
                                "field operand is required for UnaryOp");
                return NULL;
        }
        p = (expr_ty)malloc(sizeof(*p));
        if (!p) {
                PyErr_SetString(PyExc_MemoryError, "no memory");
                return NULL;
        }
        p->kind = UnaryOp_kind;
        p->v.UnaryOp.op = op;
        p->v.UnaryOp.operand = operand;
        return p;
}

expr_ty
Lambda(arguments_ty args, expr_ty body)
{
        expr_ty p;
        if (!args) {
                PyErr_SetString(PyExc_ValueError,
                                "field args is required for Lambda");
                return NULL;
        }
        if (!body) {
                PyErr_SetString(PyExc_ValueError,
                                "field body is required for Lambda");
                return NULL;
        }
        p = (expr_ty)malloc(sizeof(*p));
        if (!p) {
                PyErr_SetString(PyExc_MemoryError, "no memory");
                return NULL;
        }
        p->kind = Lambda_kind;
        p->v.Lambda.args = args;
        p->v.Lambda.body = body;
        return p;
}

expr_ty
Dict(asdl_seq * keys, asdl_seq * values)
{
        expr_ty p;
        p = (expr_ty)malloc(sizeof(*p));
        if (!p) {
                PyErr_SetString(PyExc_MemoryError, "no memory");
                return NULL;
        }
        p->kind = Dict_kind;
        p->v.Dict.keys = keys;
        p->v.Dict.values = values;
        return p;
}

expr_ty
ListComp(expr_ty target, asdl_seq * generators)
{
        expr_ty p;
        if (!target) {
                PyErr_SetString(PyExc_ValueError,
                                "field target is required for ListComp");
                return NULL;
        }
        p = (expr_ty)malloc(sizeof(*p));
        if (!p) {
                PyErr_SetString(PyExc_MemoryError, "no memory");
                return NULL;
        }
        p->kind = ListComp_kind;
        p->v.ListComp.target = target;
        p->v.ListComp.generators = generators;
        return p;
}

expr_ty
Compare(expr_ty left, asdl_seq * ops, asdl_seq * comparators)
{
        expr_ty p;
        if (!left) {
                PyErr_SetString(PyExc_ValueError,
                                "field left is required for Compare");
                return NULL;
        }
        p = (expr_ty)malloc(sizeof(*p));
        if (!p) {
                PyErr_SetString(PyExc_MemoryError, "no memory");
                return NULL;
        }
        p->kind = Compare_kind;
        p->v.Compare.left = left;
        p->v.Compare.ops = ops;
        p->v.Compare.comparators = comparators;
        return p;
}

expr_ty
Call(expr_ty func, asdl_seq * args, asdl_seq * keywords, expr_ty starargs,
     expr_ty kwargs)
{
        expr_ty p;
        if (!func) {
                PyErr_SetString(PyExc_ValueError,
                                "field func is required for Call");
                return NULL;
        }
        p = (expr_ty)malloc(sizeof(*p));
        if (!p) {
                PyErr_SetString(PyExc_MemoryError, "no memory");
                return NULL;
        }
        p->kind = Call_kind;
        p->v.Call.func = func;
        p->v.Call.args = args;
        p->v.Call.keywords = keywords;
        p->v.Call.starargs = starargs;
        p->v.Call.kwargs = kwargs;
        return p;
}

expr_ty
Repr(expr_ty value)
{
        expr_ty p;
        if (!value) {
                PyErr_SetString(PyExc_ValueError,
                                "field value is required for Repr");
                return NULL;
        }
        p = (expr_ty)malloc(sizeof(*p));
        if (!p) {
                PyErr_SetString(PyExc_MemoryError, "no memory");
                return NULL;
        }
        p->kind = Repr_kind;
        p->v.Repr.value = value;
        return p;
}

expr_ty
Num(object n)
{
        expr_ty p;
        if (!n) {
                PyErr_SetString(PyExc_ValueError,
                                "field n is required for Num");
                return NULL;
        }
        p = (expr_ty)malloc(sizeof(*p));
        if (!p) {
                PyErr_SetString(PyExc_MemoryError, "no memory");
                return NULL;
        }
        p->kind = Num_kind;
        p->v.Num.n = n;
        return p;
}

expr_ty
Str(string s)
{
        expr_ty p;
        if (!s) {
                PyErr_SetString(PyExc_ValueError,
                                "field s is required for Str");
                return NULL;
        }
        p = (expr_ty)malloc(sizeof(*p));
        if (!p) {
                PyErr_SetString(PyExc_MemoryError, "no memory");
                return NULL;
        }
        p->kind = Str_kind;
        p->v.Str.s = s;
        return p;
}

expr_ty
Attribute(expr_ty value, identifier attr, expr_context_ty ctx)
{
        expr_ty p;
        if (!value) {
                PyErr_SetString(PyExc_ValueError,
                                "field value is required for Attribute");
                return NULL;
        }
        if (!attr) {
                PyErr_SetString(PyExc_ValueError,
                                "field attr is required for Attribute");
                return NULL;
        }
        if (!ctx) {
                PyErr_SetString(PyExc_ValueError,
                                "field ctx is required for Attribute");
                return NULL;
        }
        p = (expr_ty)malloc(sizeof(*p));
        if (!p) {
                PyErr_SetString(PyExc_MemoryError, "no memory");
                return NULL;
        }
        p->kind = Attribute_kind;
        p->v.Attribute.value = value;
        p->v.Attribute.attr = attr;
        p->v.Attribute.ctx = ctx;
        return p;
}

expr_ty
Subscript(expr_ty value, slice_ty slice, expr_context_ty ctx)
{
        expr_ty p;
        if (!value) {
                PyErr_SetString(PyExc_ValueError,
                                "field value is required for Subscript");
                return NULL;
        }
        if (!slice) {
                PyErr_SetString(PyExc_ValueError,
                                "field slice is required for Subscript");
                return NULL;
        }
        if (!ctx) {
                PyErr_SetString(PyExc_ValueError,
                                "field ctx is required for Subscript");
                return NULL;
        }
        p = (expr_ty)malloc(sizeof(*p));
        if (!p) {
                PyErr_SetString(PyExc_MemoryError, "no memory");
                return NULL;
        }
        p->kind = Subscript_kind;
        p->v.Subscript.value = value;
        p->v.Subscript.slice = slice;
        p->v.Subscript.ctx = ctx;
        return p;
}

expr_ty
Name(identifier id, expr_context_ty ctx)
{
        expr_ty p;
        if (!id) {
                PyErr_SetString(PyExc_ValueError,
                                "field id is required for Name");
                return NULL;
        }
        if (!ctx) {
                PyErr_SetString(PyExc_ValueError,
                                "field ctx is required for Name");
                return NULL;
        }
        p = (expr_ty)malloc(sizeof(*p));
        if (!p) {
                PyErr_SetString(PyExc_MemoryError, "no memory");
                return NULL;
        }
        p->kind = Name_kind;
        p->v.Name.id = id;
        p->v.Name.ctx = ctx;
        return p;
}

expr_ty
List(asdl_seq * elts, expr_context_ty ctx)
{
        expr_ty p;
        if (!ctx) {
                PyErr_SetString(PyExc_ValueError,
                                "field ctx is required for List");
                return NULL;
        }
        p = (expr_ty)malloc(sizeof(*p));
        if (!p) {
                PyErr_SetString(PyExc_MemoryError, "no memory");
                return NULL;
        }
        p->kind = List_kind;
        p->v.List.elts = elts;
        p->v.List.ctx = ctx;
        return p;
}

expr_ty
Tuple(asdl_seq * elts, expr_context_ty ctx)
{
        expr_ty p;
        if (!ctx) {
                PyErr_SetString(PyExc_ValueError,
                                "field ctx is required for Tuple");
                return NULL;
        }
        p = (expr_ty)malloc(sizeof(*p));
        if (!p) {
                PyErr_SetString(PyExc_MemoryError, "no memory");
                return NULL;
        }
        p->kind = Tuple_kind;
        p->v.Tuple.elts = elts;
        p->v.Tuple.ctx = ctx;
        return p;
}

slice_ty
Ellipsis()
{
        slice_ty p;
        p = (slice_ty)malloc(sizeof(*p));
        if (!p) {
                PyErr_SetString(PyExc_MemoryError, "no memory");
                return NULL;
        }
        p->kind = Ellipsis_kind;
        return p;
}

slice_ty
Slice(expr_ty lower, expr_ty upper, expr_ty step)
{
        slice_ty p;
        p = (slice_ty)malloc(sizeof(*p));
        if (!p) {
                PyErr_SetString(PyExc_MemoryError, "no memory");
                return NULL;
        }
        p->kind = Slice_kind;
        p->v.Slice.lower = lower;
        p->v.Slice.upper = upper;
        p->v.Slice.step = step;
        return p;
}

slice_ty
ExtSlice(asdl_seq * dims)
{
        slice_ty p;
        p = (slice_ty)malloc(sizeof(*p));
        if (!p) {
                PyErr_SetString(PyExc_MemoryError, "no memory");
                return NULL;
        }
        p->kind = ExtSlice_kind;
        p->v.ExtSlice.dims = dims;
        return p;
}

slice_ty
Index(expr_ty value)
{
        slice_ty p;
        if (!value) {
                PyErr_SetString(PyExc_ValueError,
                                "field value is required for Index");
                return NULL;
        }
        p = (slice_ty)malloc(sizeof(*p));
        if (!p) {
                PyErr_SetString(PyExc_MemoryError, "no memory");
                return NULL;
        }
        p->kind = Index_kind;
        p->v.Index.value = value;
        return p;
}

listcomp_ty
listcomp(expr_ty target, expr_ty iter, asdl_seq * ifs)
{
        listcomp_ty p;
        if (!target) {
                PyErr_SetString(PyExc_ValueError,
                                "field target is required for listcomp");
                return NULL;
        }
        if (!iter) {
                PyErr_SetString(PyExc_ValueError,
                                "field iter is required for listcomp");
                return NULL;
        }
        p = (listcomp_ty)malloc(sizeof(*p));
        if (!p) {
                PyErr_SetString(PyExc_MemoryError, "no memory");
                return NULL;
        }
        p->target = target;
        p->iter = iter;
        p->ifs = ifs;
        return p;
}

excepthandler_ty
excepthandler(expr_ty type, expr_ty name, asdl_seq * body)
{
        excepthandler_ty p;
        p = (excepthandler_ty)malloc(sizeof(*p));
        if (!p) {
                PyErr_SetString(PyExc_MemoryError, "no memory");
                return NULL;
        }
        p->type = type;
        p->name = name;
        p->body = body;
        return p;
}

arguments_ty
arguments(asdl_seq * args, identifier vararg, identifier kwarg, asdl_seq *
          defaults)
{
        arguments_ty p;
        p = (arguments_ty)malloc(sizeof(*p));
        if (!p) {
                PyErr_SetString(PyExc_MemoryError, "no memory");
                return NULL;
        }
        p->args = args;
        p->vararg = vararg;
        p->kwarg = kwarg;
        p->defaults = defaults;
        return p;
}

keyword_ty
keyword(identifier arg, expr_ty value)
{
        keyword_ty p;
        if (!arg) {
                PyErr_SetString(PyExc_ValueError,
                                "field arg is required for keyword");
                return NULL;
        }
        if (!value) {
                PyErr_SetString(PyExc_ValueError,
                                "field value is required for keyword");
                return NULL;
        }
        p = (keyword_ty)malloc(sizeof(*p));
        if (!p) {
                PyErr_SetString(PyExc_MemoryError, "no memory");
                return NULL;
        }
        p->arg = arg;
        p->value = value;
        return p;
}

alias_ty
alias(identifier name, identifier asname)
{
        alias_ty p;
        if (!name) {
                PyErr_SetString(PyExc_ValueError,
                                "field name is required for alias");
                return NULL;
        }
        p = (alias_ty)malloc(sizeof(*p));
        if (!p) {
                PyErr_SetString(PyExc_MemoryError, "no memory");
                return NULL;
        }
        p->name = name;
        p->asname = asname;
        return p;
}

