/* File automatically generated by ./Parser/asdl_c.py */

#include "Python.h"
#include "Python-ast.h"


static void failed_check(const char* field, const char* expected,
                         PyObject *real)
{
    PyErr_Format(PyExc_TypeError, "invalid %s: excpected %s, found %s",
                 field, expected, real->ob_type->tp_name);
}
/* Convenience macro to simplify asdl_c.py */
#define object_Check(x) 1

static int mod_validate(PyObject*);
static int Module_validate(PyObject*);
static int Interactive_validate(PyObject*);
static int Expression_validate(PyObject*);
static int Suite_validate(PyObject*);
static int stmt_validate(PyObject*);
static int FunctionDef_validate(PyObject*);
static int ClassDef_validate(PyObject*);
static int Return_validate(PyObject*);
static int Delete_validate(PyObject*);
static int Assign_validate(PyObject*);
static int AugAssign_validate(PyObject*);
static int Print_validate(PyObject*);
static int For_validate(PyObject*);
static int While_validate(PyObject*);
static int If_validate(PyObject*);
static int Raise_validate(PyObject*);
static int TryExcept_validate(PyObject*);
static int TryFinally_validate(PyObject*);
static int Assert_validate(PyObject*);
static int Import_validate(PyObject*);
static int ImportFrom_validate(PyObject*);
static int Exec_validate(PyObject*);
static int Global_validate(PyObject*);
static int Expr_validate(PyObject*);
static int Pass_validate(PyObject*);
static int Break_validate(PyObject*);
static int Continue_validate(PyObject*);
static int expr_validate(PyObject*);
static int BoolOp_validate(PyObject*);
static int BinOp_validate(PyObject*);
static int UnaryOp_validate(PyObject*);
static int Lambda_validate(PyObject*);
static int Dict_validate(PyObject*);
static int ListComp_validate(PyObject*);
static int GeneratorExp_validate(PyObject*);
static int Yield_validate(PyObject*);
static int Compare_validate(PyObject*);
static int Call_validate(PyObject*);
static int Repr_validate(PyObject*);
static int Num_validate(PyObject*);
static int Str_validate(PyObject*);
static int Attribute_validate(PyObject*);
static int Subscript_validate(PyObject*);
static int Name_validate(PyObject*);
static int List_validate(PyObject*);
static int Tuple_validate(PyObject*);
static int expr_context_validate(PyObject*);
static int Load_validate(PyObject*);
static int Store_validate(PyObject*);
static int Del_validate(PyObject*);
static int AugLoad_validate(PyObject*);
static int AugStore_validate(PyObject*);
static int Param_validate(PyObject*);
static int slice_validate(PyObject*);
static int Ellipsis_validate(PyObject*);
static int Slice_validate(PyObject*);
static int ExtSlice_validate(PyObject*);
static int Index_validate(PyObject*);
static int boolop_validate(PyObject*);
static int And_validate(PyObject*);
static int Or_validate(PyObject*);
static int operator_validate(PyObject*);
static int Add_validate(PyObject*);
static int Sub_validate(PyObject*);
static int Mult_validate(PyObject*);
static int Div_validate(PyObject*);
static int Mod_validate(PyObject*);
static int Pow_validate(PyObject*);
static int LShift_validate(PyObject*);
static int RShift_validate(PyObject*);
static int BitOr_validate(PyObject*);
static int BitXor_validate(PyObject*);
static int BitAnd_validate(PyObject*);
static int FloorDiv_validate(PyObject*);
static int unaryop_validate(PyObject*);
static int Invert_validate(PyObject*);
static int Not_validate(PyObject*);
static int UAdd_validate(PyObject*);
static int USub_validate(PyObject*);
static int cmpop_validate(PyObject*);
static int Eq_validate(PyObject*);
static int NotEq_validate(PyObject*);
static int Lt_validate(PyObject*);
static int LtE_validate(PyObject*);
static int Gt_validate(PyObject*);
static int GtE_validate(PyObject*);
static int Is_validate(PyObject*);
static int IsNot_validate(PyObject*);
static int In_validate(PyObject*);
static int NotIn_validate(PyObject*);
static int comprehension_validate(PyObject*);
static int excepthandler_validate(PyObject*);
static int arguments_validate(PyObject*);
static int keyword_validate(PyObject*);
static int alias_validate(PyObject*);

#define mod_dealloc 0
PyTypeObject Py_mod_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "mod",		/*tp_name*/
        sizeof(struct _mod),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        mod_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

int
mod_validate(PyObject* _obj)
{
        struct _mod *obj = (struct _mod*)_obj;
        assert(mod_Check(_obj));
        switch(obj->_kind) {
                case Module_kind:
                    return Module_validate(_obj);
                case Interactive_kind:
                    return Interactive_validate(_obj);
                case Expression_kind:
                    return Expression_validate(_obj);
                case Suite_kind:
                    return Suite_validate(_obj);
        }
        PyErr_SetString(PyExc_TypeError, "invalid _kind in mod");
        return -1;
}
PyObject*
Py_Module_New(PyObject* body)
{
        struct _Module *result = PyObject_New(struct _Module, &Py_Module_Type);
        if (result == NULL)
                return NULL;
        if (body == NULL)
                body = PyList_New(0);
        Py_INCREF(body);
        result->body = body;
        result->_base._kind = Module_kind;
        return (PyObject*)result;
}

static void
Module_dealloc(PyObject* _self)
{
        struct _Module *self = (struct _Module*)_self;
        Py_DECREF(self->body);
        PyObject_Del(self);
}

PyTypeObject Py_Module_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "Module",		/*tp_name*/
        sizeof(struct _Module),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        Module_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

static int
Module_validate(PyObject *_obj)
{
        struct _Module *obj = (struct _Module*)_obj;
        int i;
        if (!PyList_Check(obj->body)) {
           failed_check("body", "list", obj->body);
           return -1;
        }
        for(i = 0; i < PyList_Size(obj->body); i++) {
                if (!stmt_Check(PyList_GET_ITEM(obj->body, i))) {
                    failed_check("body", "stmt", PyList_GET_ITEM(obj->body, i));
                    return -1;
                }
                if (stmt_validate(PyList_GET_ITEM(obj->body, i)) < 0)
                    return -1;
        }
        return 0;
}

PyObject*
Py_Interactive_New(PyObject* body)
{
        struct _Interactive *result = PyObject_New(struct _Interactive, &Py_Interactive_Type);
        if (result == NULL)
                return NULL;
        if (body == NULL)
                body = PyList_New(0);
        Py_INCREF(body);
        result->body = body;
        result->_base._kind = Interactive_kind;
        return (PyObject*)result;
}

static void
Interactive_dealloc(PyObject* _self)
{
        struct _Interactive *self = (struct _Interactive*)_self;
        Py_DECREF(self->body);
        PyObject_Del(self);
}

PyTypeObject Py_Interactive_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "Interactive",		/*tp_name*/
        sizeof(struct _Interactive),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        Interactive_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

static int
Interactive_validate(PyObject *_obj)
{
        struct _Interactive *obj = (struct _Interactive*)_obj;
        int i;
        if (!PyList_Check(obj->body)) {
           failed_check("body", "list", obj->body);
           return -1;
        }
        for(i = 0; i < PyList_Size(obj->body); i++) {
                if (!stmt_Check(PyList_GET_ITEM(obj->body, i))) {
                    failed_check("body", "stmt", PyList_GET_ITEM(obj->body, i));
                    return -1;
                }
                if (stmt_validate(PyList_GET_ITEM(obj->body, i)) < 0)
                    return -1;
        }
        return 0;
}

PyObject*
Py_Expression_New(PyObject* body)
{
        struct _Expression *result = PyObject_New(struct _Expression, &Py_Expression_Type);
        if (result == NULL)
                return NULL;
        Py_INCREF(body);
        result->body = body;
        result->_base._kind = Expression_kind;
        return (PyObject*)result;
}

static void
Expression_dealloc(PyObject* _self)
{
        struct _Expression *self = (struct _Expression*)_self;
        Py_DECREF(self->body);
        PyObject_Del(self);
}

PyTypeObject Py_Expression_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "Expression",		/*tp_name*/
        sizeof(struct _Expression),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        Expression_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

static int
Expression_validate(PyObject *_obj)
{
        struct _Expression *obj = (struct _Expression*)_obj;
        if (!expr_Check(obj->body)) {
            failed_check("body", "expr", obj->body);
            return -1;
        }
        return 0;
}

PyObject*
Py_Suite_New(PyObject* body)
{
        struct _Suite *result = PyObject_New(struct _Suite, &Py_Suite_Type);
        if (result == NULL)
                return NULL;
        if (body == NULL)
                body = PyList_New(0);
        Py_INCREF(body);
        result->body = body;
        result->_base._kind = Suite_kind;
        return (PyObject*)result;
}

static void
Suite_dealloc(PyObject* _self)
{
        struct _Suite *self = (struct _Suite*)_self;
        Py_DECREF(self->body);
        PyObject_Del(self);
}

PyTypeObject Py_Suite_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "Suite",		/*tp_name*/
        sizeof(struct _Suite),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        Suite_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

static int
Suite_validate(PyObject *_obj)
{
        struct _Suite *obj = (struct _Suite*)_obj;
        int i;
        if (!PyList_Check(obj->body)) {
           failed_check("body", "list", obj->body);
           return -1;
        }
        for(i = 0; i < PyList_Size(obj->body); i++) {
                if (!stmt_Check(PyList_GET_ITEM(obj->body, i))) {
                    failed_check("body", "stmt", PyList_GET_ITEM(obj->body, i));
                    return -1;
                }
                if (stmt_validate(PyList_GET_ITEM(obj->body, i)) < 0)
                    return -1;
        }
        return 0;
}

#define stmt_dealloc 0
PyTypeObject Py_stmt_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "stmt",		/*tp_name*/
        sizeof(struct _stmt),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        stmt_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

int
stmt_validate(PyObject* _obj)
{
        struct _stmt *obj = (struct _stmt*)_obj;
        assert(stmt_Check(_obj));
        switch(obj->_kind) {
                case FunctionDef_kind:
                    return FunctionDef_validate(_obj);
                case ClassDef_kind:
                    return ClassDef_validate(_obj);
                case Return_kind:
                    return Return_validate(_obj);
                case Delete_kind:
                    return Delete_validate(_obj);
                case Assign_kind:
                    return Assign_validate(_obj);
                case AugAssign_kind:
                    return AugAssign_validate(_obj);
                case Print_kind:
                    return Print_validate(_obj);
                case For_kind:
                    return For_validate(_obj);
                case While_kind:
                    return While_validate(_obj);
                case If_kind:
                    return If_validate(_obj);
                case Raise_kind:
                    return Raise_validate(_obj);
                case TryExcept_kind:
                    return TryExcept_validate(_obj);
                case TryFinally_kind:
                    return TryFinally_validate(_obj);
                case Assert_kind:
                    return Assert_validate(_obj);
                case Import_kind:
                    return Import_validate(_obj);
                case ImportFrom_kind:
                    return ImportFrom_validate(_obj);
                case Exec_kind:
                    return Exec_validate(_obj);
                case Global_kind:
                    return Global_validate(_obj);
                case Expr_kind:
                    return Expr_validate(_obj);
                case Pass_kind:
                    return Pass_validate(_obj);
                case Break_kind:
                    return Break_validate(_obj);
                case Continue_kind:
                    return Continue_validate(_obj);
        }
        PyErr_SetString(PyExc_TypeError, "invalid _kind in stmt");
        return -1;
}
PyObject*
Py_FunctionDef_New(PyObject* name, PyObject* args, PyObject* body, PyObject*
                   decorators, int lineno)
{
        struct _FunctionDef *result = PyObject_New(struct _FunctionDef, &Py_FunctionDef_Type);
        if (result == NULL)
                return NULL;
        Py_INCREF(name);
        result->name = name;
        Py_INCREF(args);
        result->args = args;
        if (body == NULL)
                body = PyList_New(0);
        Py_INCREF(body);
        result->body = body;
        if (decorators == NULL)
                decorators = PyList_New(0);
        Py_INCREF(decorators);
        result->decorators = decorators;
        result->_base._kind = FunctionDef_kind;
        result->_base.lineno = lineno;
        return (PyObject*)result;
}

static void
FunctionDef_dealloc(PyObject* _self)
{
        struct _FunctionDef *self = (struct _FunctionDef*)_self;
        Py_DECREF(self->name);
        Py_DECREF(self->args);
        Py_DECREF(self->body);
        Py_DECREF(self->decorators);
        PyObject_Del(self);
}

PyTypeObject Py_FunctionDef_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "FunctionDef",		/*tp_name*/
        sizeof(struct _FunctionDef),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        FunctionDef_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

static int
FunctionDef_validate(PyObject *_obj)
{
        struct _FunctionDef *obj = (struct _FunctionDef*)_obj;
        int i;
        if (!PyString_Check(obj->name)) {
            failed_check("name", "identifier", obj->name);
            return -1;
        }
        if (!arguments_Check(obj->args)) {
            failed_check("args", "arguments", obj->args);
            return -1;
        }
        if (!PyList_Check(obj->body)) {
           failed_check("body", "list", obj->body);
           return -1;
        }
        for(i = 0; i < PyList_Size(obj->body); i++) {
                if (!stmt_Check(PyList_GET_ITEM(obj->body, i))) {
                    failed_check("body", "stmt", PyList_GET_ITEM(obj->body, i));
                    return -1;
                }
                if (stmt_validate(PyList_GET_ITEM(obj->body, i)) < 0)
                    return -1;
        }
        if (!PyList_Check(obj->decorators)) {
           failed_check("decorators", "list", obj->decorators);
           return -1;
        }
        for(i = 0; i < PyList_Size(obj->decorators); i++) {
                if (!expr_Check(PyList_GET_ITEM(obj->decorators, i))) {
                    failed_check("decorators", "expr",
                                 PyList_GET_ITEM(obj->decorators, i));
                    return -1;
                }
                if (expr_validate(PyList_GET_ITEM(obj->decorators, i)) < 0)
                    return -1;
        }
        return 0;
}

PyObject*
Py_ClassDef_New(PyObject* name, PyObject* bases, PyObject* body, int lineno)
{
        struct _ClassDef *result = PyObject_New(struct _ClassDef, &Py_ClassDef_Type);
        if (result == NULL)
                return NULL;
        Py_INCREF(name);
        result->name = name;
        if (bases == NULL)
                bases = PyList_New(0);
        Py_INCREF(bases);
        result->bases = bases;
        if (body == NULL)
                body = PyList_New(0);
        Py_INCREF(body);
        result->body = body;
        result->_base._kind = ClassDef_kind;
        result->_base.lineno = lineno;
        return (PyObject*)result;
}

static void
ClassDef_dealloc(PyObject* _self)
{
        struct _ClassDef *self = (struct _ClassDef*)_self;
        Py_DECREF(self->name);
        Py_DECREF(self->bases);
        Py_DECREF(self->body);
        PyObject_Del(self);
}

PyTypeObject Py_ClassDef_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "ClassDef",		/*tp_name*/
        sizeof(struct _ClassDef),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        ClassDef_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

static int
ClassDef_validate(PyObject *_obj)
{
        struct _ClassDef *obj = (struct _ClassDef*)_obj;
        int i;
        if (!PyString_Check(obj->name)) {
            failed_check("name", "identifier", obj->name);
            return -1;
        }
        if (!PyList_Check(obj->bases)) {
           failed_check("bases", "list", obj->bases);
           return -1;
        }
        for(i = 0; i < PyList_Size(obj->bases); i++) {
                if (!expr_Check(PyList_GET_ITEM(obj->bases, i))) {
                    failed_check("bases", "expr", PyList_GET_ITEM(obj->bases,
                                 i));
                    return -1;
                }
                if (expr_validate(PyList_GET_ITEM(obj->bases, i)) < 0)
                    return -1;
        }
        if (!PyList_Check(obj->body)) {
           failed_check("body", "list", obj->body);
           return -1;
        }
        for(i = 0; i < PyList_Size(obj->body); i++) {
                if (!stmt_Check(PyList_GET_ITEM(obj->body, i))) {
                    failed_check("body", "stmt", PyList_GET_ITEM(obj->body, i));
                    return -1;
                }
                if (stmt_validate(PyList_GET_ITEM(obj->body, i)) < 0)
                    return -1;
        }
        return 0;
}

PyObject*
Py_Return_New(PyObject* value, int lineno)
{
        struct _Return *result = PyObject_New(struct _Return, &Py_Return_Type);
        if (result == NULL)
                return NULL;
        if (value == NULL) {
                Py_INCREF(Py_None);
                value = Py_None;
        }
        Py_INCREF(value);
        result->value = value;
        result->_base._kind = Return_kind;
        result->_base.lineno = lineno;
        return (PyObject*)result;
}

static void
Return_dealloc(PyObject* _self)
{
        struct _Return *self = (struct _Return*)_self;
        Py_DECREF(self->value);
        PyObject_Del(self);
}

PyTypeObject Py_Return_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "Return",		/*tp_name*/
        sizeof(struct _Return),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        Return_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

static int
Return_validate(PyObject *_obj)
{
        struct _Return *obj = (struct _Return*)_obj;
        if (obj->value == Py_None) /* empty */;
        else if (!expr_Check(obj->value)) {
            failed_check("value", "expr", obj->value);
            return -1;
        }
        else if (expr_validate(obj->value) < 0)
            return -1;
        return 0;
}

PyObject*
Py_Delete_New(PyObject* targets, int lineno)
{
        struct _Delete *result = PyObject_New(struct _Delete, &Py_Delete_Type);
        if (result == NULL)
                return NULL;
        if (targets == NULL)
                targets = PyList_New(0);
        Py_INCREF(targets);
        result->targets = targets;
        result->_base._kind = Delete_kind;
        result->_base.lineno = lineno;
        return (PyObject*)result;
}

static void
Delete_dealloc(PyObject* _self)
{
        struct _Delete *self = (struct _Delete*)_self;
        Py_DECREF(self->targets);
        PyObject_Del(self);
}

PyTypeObject Py_Delete_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "Delete",		/*tp_name*/
        sizeof(struct _Delete),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        Delete_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

static int
Delete_validate(PyObject *_obj)
{
        struct _Delete *obj = (struct _Delete*)_obj;
        int i;
        if (!PyList_Check(obj->targets)) {
           failed_check("targets", "list", obj->targets);
           return -1;
        }
        for(i = 0; i < PyList_Size(obj->targets); i++) {
                if (!expr_Check(PyList_GET_ITEM(obj->targets, i))) {
                    failed_check("targets", "expr",
                                 PyList_GET_ITEM(obj->targets, i));
                    return -1;
                }
                if (expr_validate(PyList_GET_ITEM(obj->targets, i)) < 0)
                    return -1;
        }
        return 0;
}

PyObject*
Py_Assign_New(PyObject* targets, PyObject* value, int lineno)
{
        struct _Assign *result = PyObject_New(struct _Assign, &Py_Assign_Type);
        if (result == NULL)
                return NULL;
        if (targets == NULL)
                targets = PyList_New(0);
        Py_INCREF(targets);
        result->targets = targets;
        Py_INCREF(value);
        result->value = value;
        result->_base._kind = Assign_kind;
        result->_base.lineno = lineno;
        return (PyObject*)result;
}

static void
Assign_dealloc(PyObject* _self)
{
        struct _Assign *self = (struct _Assign*)_self;
        Py_DECREF(self->targets);
        Py_DECREF(self->value);
        PyObject_Del(self);
}

PyTypeObject Py_Assign_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "Assign",		/*tp_name*/
        sizeof(struct _Assign),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        Assign_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

static int
Assign_validate(PyObject *_obj)
{
        struct _Assign *obj = (struct _Assign*)_obj;
        int i;
        if (!PyList_Check(obj->targets)) {
           failed_check("targets", "list", obj->targets);
           return -1;
        }
        for(i = 0; i < PyList_Size(obj->targets); i++) {
                if (!expr_Check(PyList_GET_ITEM(obj->targets, i))) {
                    failed_check("targets", "expr",
                                 PyList_GET_ITEM(obj->targets, i));
                    return -1;
                }
                if (expr_validate(PyList_GET_ITEM(obj->targets, i)) < 0)
                    return -1;
        }
        if (!expr_Check(obj->value)) {
            failed_check("value", "expr", obj->value);
            return -1;
        }
        return 0;
}

PyObject*
Py_AugAssign_New(PyObject* target, PyObject* op, PyObject* value, int lineno)
{
        struct _AugAssign *result = PyObject_New(struct _AugAssign, &Py_AugAssign_Type);
        if (result == NULL)
                return NULL;
        Py_INCREF(target);
        result->target = target;
        Py_INCREF(op);
        result->op = op;
        Py_INCREF(value);
        result->value = value;
        result->_base._kind = AugAssign_kind;
        result->_base.lineno = lineno;
        return (PyObject*)result;
}

static void
AugAssign_dealloc(PyObject* _self)
{
        struct _AugAssign *self = (struct _AugAssign*)_self;
        Py_DECREF(self->target);
        Py_DECREF(self->op);
        Py_DECREF(self->value);
        PyObject_Del(self);
}

PyTypeObject Py_AugAssign_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "AugAssign",		/*tp_name*/
        sizeof(struct _AugAssign),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        AugAssign_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

static int
AugAssign_validate(PyObject *_obj)
{
        struct _AugAssign *obj = (struct _AugAssign*)_obj;
        if (!expr_Check(obj->target)) {
            failed_check("target", "expr", obj->target);
            return -1;
        }
        if (!operator_Check(obj->op)) {
            failed_check("op", "operator", obj->op);
            return -1;
        }
        if (!expr_Check(obj->value)) {
            failed_check("value", "expr", obj->value);
            return -1;
        }
        return 0;
}

PyObject*
Py_Print_New(PyObject* dest, PyObject* values, PyObject* nl, int lineno)
{
        struct _Print *result = PyObject_New(struct _Print, &Py_Print_Type);
        if (result == NULL)
                return NULL;
        if (dest == NULL) {
                Py_INCREF(Py_None);
                dest = Py_None;
        }
        Py_INCREF(dest);
        result->dest = dest;
        if (values == NULL)
                values = PyList_New(0);
        Py_INCREF(values);
        result->values = values;
        Py_INCREF(nl);
        result->nl = nl;
        result->_base._kind = Print_kind;
        result->_base.lineno = lineno;
        return (PyObject*)result;
}

static void
Print_dealloc(PyObject* _self)
{
        struct _Print *self = (struct _Print*)_self;
        Py_DECREF(self->dest);
        Py_DECREF(self->values);
        Py_DECREF(self->nl);
        PyObject_Del(self);
}

PyTypeObject Py_Print_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "Print",		/*tp_name*/
        sizeof(struct _Print),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        Print_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

static int
Print_validate(PyObject *_obj)
{
        struct _Print *obj = (struct _Print*)_obj;
        int i;
        if (obj->dest == Py_None) /* empty */;
        else if (!expr_Check(obj->dest)) {
            failed_check("dest", "expr", obj->dest);
            return -1;
        }
        else if (expr_validate(obj->dest) < 0)
            return -1;
        if (!PyList_Check(obj->values)) {
           failed_check("values", "list", obj->values);
           return -1;
        }
        for(i = 0; i < PyList_Size(obj->values); i++) {
                if (!expr_Check(PyList_GET_ITEM(obj->values, i))) {
                    failed_check("values", "expr", PyList_GET_ITEM(obj->values,
                                 i));
                    return -1;
                }
                if (expr_validate(PyList_GET_ITEM(obj->values, i)) < 0)
                    return -1;
        }
        if (!PyBool_Check(obj->nl)) {
            failed_check("nl", "bool", obj->nl);
            return -1;
        }
        return 0;
}

PyObject*
Py_For_New(PyObject* target, PyObject* iter, PyObject* body, PyObject* orelse,
           int lineno)
{
        struct _For *result = PyObject_New(struct _For, &Py_For_Type);
        if (result == NULL)
                return NULL;
        Py_INCREF(target);
        result->target = target;
        Py_INCREF(iter);
        result->iter = iter;
        if (body == NULL)
                body = PyList_New(0);
        Py_INCREF(body);
        result->body = body;
        if (orelse == NULL)
                orelse = PyList_New(0);
        Py_INCREF(orelse);
        result->orelse = orelse;
        result->_base._kind = For_kind;
        result->_base.lineno = lineno;
        return (PyObject*)result;
}

static void
For_dealloc(PyObject* _self)
{
        struct _For *self = (struct _For*)_self;
        Py_DECREF(self->target);
        Py_DECREF(self->iter);
        Py_DECREF(self->body);
        Py_DECREF(self->orelse);
        PyObject_Del(self);
}

PyTypeObject Py_For_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "For",		/*tp_name*/
        sizeof(struct _For),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        For_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

static int
For_validate(PyObject *_obj)
{
        struct _For *obj = (struct _For*)_obj;
        int i;
        if (!expr_Check(obj->target)) {
            failed_check("target", "expr", obj->target);
            return -1;
        }
        if (!expr_Check(obj->iter)) {
            failed_check("iter", "expr", obj->iter);
            return -1;
        }
        if (!PyList_Check(obj->body)) {
           failed_check("body", "list", obj->body);
           return -1;
        }
        for(i = 0; i < PyList_Size(obj->body); i++) {
                if (!stmt_Check(PyList_GET_ITEM(obj->body, i))) {
                    failed_check("body", "stmt", PyList_GET_ITEM(obj->body, i));
                    return -1;
                }
                if (stmt_validate(PyList_GET_ITEM(obj->body, i)) < 0)
                    return -1;
        }
        if (!PyList_Check(obj->orelse)) {
           failed_check("orelse", "list", obj->orelse);
           return -1;
        }
        for(i = 0; i < PyList_Size(obj->orelse); i++) {
                if (!stmt_Check(PyList_GET_ITEM(obj->orelse, i))) {
                    failed_check("orelse", "stmt", PyList_GET_ITEM(obj->orelse,
                                 i));
                    return -1;
                }
                if (stmt_validate(PyList_GET_ITEM(obj->orelse, i)) < 0)
                    return -1;
        }
        return 0;
}

PyObject*
Py_While_New(PyObject* test, PyObject* body, PyObject* orelse, int lineno)
{
        struct _While *result = PyObject_New(struct _While, &Py_While_Type);
        if (result == NULL)
                return NULL;
        Py_INCREF(test);
        result->test = test;
        if (body == NULL)
                body = PyList_New(0);
        Py_INCREF(body);
        result->body = body;
        if (orelse == NULL)
                orelse = PyList_New(0);
        Py_INCREF(orelse);
        result->orelse = orelse;
        result->_base._kind = While_kind;
        result->_base.lineno = lineno;
        return (PyObject*)result;
}

static void
While_dealloc(PyObject* _self)
{
        struct _While *self = (struct _While*)_self;
        Py_DECREF(self->test);
        Py_DECREF(self->body);
        Py_DECREF(self->orelse);
        PyObject_Del(self);
}

PyTypeObject Py_While_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "While",		/*tp_name*/
        sizeof(struct _While),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        While_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

static int
While_validate(PyObject *_obj)
{
        struct _While *obj = (struct _While*)_obj;
        int i;
        if (!expr_Check(obj->test)) {
            failed_check("test", "expr", obj->test);
            return -1;
        }
        if (!PyList_Check(obj->body)) {
           failed_check("body", "list", obj->body);
           return -1;
        }
        for(i = 0; i < PyList_Size(obj->body); i++) {
                if (!stmt_Check(PyList_GET_ITEM(obj->body, i))) {
                    failed_check("body", "stmt", PyList_GET_ITEM(obj->body, i));
                    return -1;
                }
                if (stmt_validate(PyList_GET_ITEM(obj->body, i)) < 0)
                    return -1;
        }
        if (!PyList_Check(obj->orelse)) {
           failed_check("orelse", "list", obj->orelse);
           return -1;
        }
        for(i = 0; i < PyList_Size(obj->orelse); i++) {
                if (!stmt_Check(PyList_GET_ITEM(obj->orelse, i))) {
                    failed_check("orelse", "stmt", PyList_GET_ITEM(obj->orelse,
                                 i));
                    return -1;
                }
                if (stmt_validate(PyList_GET_ITEM(obj->orelse, i)) < 0)
                    return -1;
        }
        return 0;
}

PyObject*
Py_If_New(PyObject* test, PyObject* body, PyObject* orelse, int lineno)
{
        struct _If *result = PyObject_New(struct _If, &Py_If_Type);
        if (result == NULL)
                return NULL;
        Py_INCREF(test);
        result->test = test;
        if (body == NULL)
                body = PyList_New(0);
        Py_INCREF(body);
        result->body = body;
        if (orelse == NULL)
                orelse = PyList_New(0);
        Py_INCREF(orelse);
        result->orelse = orelse;
        result->_base._kind = If_kind;
        result->_base.lineno = lineno;
        return (PyObject*)result;
}

static void
If_dealloc(PyObject* _self)
{
        struct _If *self = (struct _If*)_self;
        Py_DECREF(self->test);
        Py_DECREF(self->body);
        Py_DECREF(self->orelse);
        PyObject_Del(self);
}

PyTypeObject Py_If_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "If",		/*tp_name*/
        sizeof(struct _If),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        If_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

static int
If_validate(PyObject *_obj)
{
        struct _If *obj = (struct _If*)_obj;
        int i;
        if (!expr_Check(obj->test)) {
            failed_check("test", "expr", obj->test);
            return -1;
        }
        if (!PyList_Check(obj->body)) {
           failed_check("body", "list", obj->body);
           return -1;
        }
        for(i = 0; i < PyList_Size(obj->body); i++) {
                if (!stmt_Check(PyList_GET_ITEM(obj->body, i))) {
                    failed_check("body", "stmt", PyList_GET_ITEM(obj->body, i));
                    return -1;
                }
                if (stmt_validate(PyList_GET_ITEM(obj->body, i)) < 0)
                    return -1;
        }
        if (!PyList_Check(obj->orelse)) {
           failed_check("orelse", "list", obj->orelse);
           return -1;
        }
        for(i = 0; i < PyList_Size(obj->orelse); i++) {
                if (!stmt_Check(PyList_GET_ITEM(obj->orelse, i))) {
                    failed_check("orelse", "stmt", PyList_GET_ITEM(obj->orelse,
                                 i));
                    return -1;
                }
                if (stmt_validate(PyList_GET_ITEM(obj->orelse, i)) < 0)
                    return -1;
        }
        return 0;
}

PyObject*
Py_Raise_New(PyObject* type, PyObject* inst, PyObject* tback, int lineno)
{
        struct _Raise *result = PyObject_New(struct _Raise, &Py_Raise_Type);
        if (result == NULL)
                return NULL;
        if (type == NULL) {
                Py_INCREF(Py_None);
                type = Py_None;
        }
        Py_INCREF(type);
        result->type = type;
        if (inst == NULL) {
                Py_INCREF(Py_None);
                inst = Py_None;
        }
        Py_INCREF(inst);
        result->inst = inst;
        if (tback == NULL) {
                Py_INCREF(Py_None);
                tback = Py_None;
        }
        Py_INCREF(tback);
        result->tback = tback;
        result->_base._kind = Raise_kind;
        result->_base.lineno = lineno;
        return (PyObject*)result;
}

static void
Raise_dealloc(PyObject* _self)
{
        struct _Raise *self = (struct _Raise*)_self;
        Py_DECREF(self->type);
        Py_DECREF(self->inst);
        Py_DECREF(self->tback);
        PyObject_Del(self);
}

PyTypeObject Py_Raise_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "Raise",		/*tp_name*/
        sizeof(struct _Raise),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        Raise_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

static int
Raise_validate(PyObject *_obj)
{
        struct _Raise *obj = (struct _Raise*)_obj;
        if (obj->type == Py_None) /* empty */;
        else if (!expr_Check(obj->type)) {
            failed_check("type", "expr", obj->type);
            return -1;
        }
        else if (expr_validate(obj->type) < 0)
            return -1;
        if (obj->inst == Py_None) /* empty */;
        else if (!expr_Check(obj->inst)) {
            failed_check("inst", "expr", obj->inst);
            return -1;
        }
        else if (expr_validate(obj->inst) < 0)
            return -1;
        if (obj->tback == Py_None) /* empty */;
        else if (!expr_Check(obj->tback)) {
            failed_check("tback", "expr", obj->tback);
            return -1;
        }
        else if (expr_validate(obj->tback) < 0)
            return -1;
        return 0;
}

PyObject*
Py_TryExcept_New(PyObject* body, PyObject* handlers, PyObject* orelse, int
                 lineno)
{
        struct _TryExcept *result = PyObject_New(struct _TryExcept, &Py_TryExcept_Type);
        if (result == NULL)
                return NULL;
        if (body == NULL)
                body = PyList_New(0);
        Py_INCREF(body);
        result->body = body;
        if (handlers == NULL)
                handlers = PyList_New(0);
        Py_INCREF(handlers);
        result->handlers = handlers;
        if (orelse == NULL)
                orelse = PyList_New(0);
        Py_INCREF(orelse);
        result->orelse = orelse;
        result->_base._kind = TryExcept_kind;
        result->_base.lineno = lineno;
        return (PyObject*)result;
}

static void
TryExcept_dealloc(PyObject* _self)
{
        struct _TryExcept *self = (struct _TryExcept*)_self;
        Py_DECREF(self->body);
        Py_DECREF(self->handlers);
        Py_DECREF(self->orelse);
        PyObject_Del(self);
}

PyTypeObject Py_TryExcept_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "TryExcept",		/*tp_name*/
        sizeof(struct _TryExcept),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        TryExcept_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

static int
TryExcept_validate(PyObject *_obj)
{
        struct _TryExcept *obj = (struct _TryExcept*)_obj;
        int i;
        if (!PyList_Check(obj->body)) {
           failed_check("body", "list", obj->body);
           return -1;
        }
        for(i = 0; i < PyList_Size(obj->body); i++) {
                if (!stmt_Check(PyList_GET_ITEM(obj->body, i))) {
                    failed_check("body", "stmt", PyList_GET_ITEM(obj->body, i));
                    return -1;
                }
                if (stmt_validate(PyList_GET_ITEM(obj->body, i)) < 0)
                    return -1;
        }
        if (!PyList_Check(obj->handlers)) {
           failed_check("handlers", "list", obj->handlers);
           return -1;
        }
        for(i = 0; i < PyList_Size(obj->handlers); i++) {
                if (!excepthandler_Check(PyList_GET_ITEM(obj->handlers, i))) {
                    failed_check("handlers", "excepthandler",
                                 PyList_GET_ITEM(obj->handlers, i));
                    return -1;
                }
                if (excepthandler_validate(PyList_GET_ITEM(obj->handlers, i)) <
                    0)
                    return -1;
        }
        if (!PyList_Check(obj->orelse)) {
           failed_check("orelse", "list", obj->orelse);
           return -1;
        }
        for(i = 0; i < PyList_Size(obj->orelse); i++) {
                if (!stmt_Check(PyList_GET_ITEM(obj->orelse, i))) {
                    failed_check("orelse", "stmt", PyList_GET_ITEM(obj->orelse,
                                 i));
                    return -1;
                }
                if (stmt_validate(PyList_GET_ITEM(obj->orelse, i)) < 0)
                    return -1;
        }
        return 0;
}

PyObject*
Py_TryFinally_New(PyObject* body, PyObject* finalbody, int lineno)
{
        struct _TryFinally *result = PyObject_New(struct _TryFinally, &Py_TryFinally_Type);
        if (result == NULL)
                return NULL;
        if (body == NULL)
                body = PyList_New(0);
        Py_INCREF(body);
        result->body = body;
        if (finalbody == NULL)
                finalbody = PyList_New(0);
        Py_INCREF(finalbody);
        result->finalbody = finalbody;
        result->_base._kind = TryFinally_kind;
        result->_base.lineno = lineno;
        return (PyObject*)result;
}

static void
TryFinally_dealloc(PyObject* _self)
{
        struct _TryFinally *self = (struct _TryFinally*)_self;
        Py_DECREF(self->body);
        Py_DECREF(self->finalbody);
        PyObject_Del(self);
}

PyTypeObject Py_TryFinally_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "TryFinally",		/*tp_name*/
        sizeof(struct _TryFinally),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        TryFinally_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

static int
TryFinally_validate(PyObject *_obj)
{
        struct _TryFinally *obj = (struct _TryFinally*)_obj;
        int i;
        if (!PyList_Check(obj->body)) {
           failed_check("body", "list", obj->body);
           return -1;
        }
        for(i = 0; i < PyList_Size(obj->body); i++) {
                if (!stmt_Check(PyList_GET_ITEM(obj->body, i))) {
                    failed_check("body", "stmt", PyList_GET_ITEM(obj->body, i));
                    return -1;
                }
                if (stmt_validate(PyList_GET_ITEM(obj->body, i)) < 0)
                    return -1;
        }
        if (!PyList_Check(obj->finalbody)) {
           failed_check("finalbody", "list", obj->finalbody);
           return -1;
        }
        for(i = 0; i < PyList_Size(obj->finalbody); i++) {
                if (!stmt_Check(PyList_GET_ITEM(obj->finalbody, i))) {
                    failed_check("finalbody", "stmt",
                                 PyList_GET_ITEM(obj->finalbody, i));
                    return -1;
                }
                if (stmt_validate(PyList_GET_ITEM(obj->finalbody, i)) < 0)
                    return -1;
        }
        return 0;
}

PyObject*
Py_Assert_New(PyObject* test, PyObject* msg, int lineno)
{
        struct _Assert *result = PyObject_New(struct _Assert, &Py_Assert_Type);
        if (result == NULL)
                return NULL;
        Py_INCREF(test);
        result->test = test;
        if (msg == NULL) {
                Py_INCREF(Py_None);
                msg = Py_None;
        }
        Py_INCREF(msg);
        result->msg = msg;
        result->_base._kind = Assert_kind;
        result->_base.lineno = lineno;
        return (PyObject*)result;
}

static void
Assert_dealloc(PyObject* _self)
{
        struct _Assert *self = (struct _Assert*)_self;
        Py_DECREF(self->test);
        Py_DECREF(self->msg);
        PyObject_Del(self);
}

PyTypeObject Py_Assert_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "Assert",		/*tp_name*/
        sizeof(struct _Assert),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        Assert_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

static int
Assert_validate(PyObject *_obj)
{
        struct _Assert *obj = (struct _Assert*)_obj;
        if (!expr_Check(obj->test)) {
            failed_check("test", "expr", obj->test);
            return -1;
        }
        if (obj->msg == Py_None) /* empty */;
        else if (!expr_Check(obj->msg)) {
            failed_check("msg", "expr", obj->msg);
            return -1;
        }
        else if (expr_validate(obj->msg) < 0)
            return -1;
        return 0;
}

PyObject*
Py_Import_New(PyObject* names, int lineno)
{
        struct _Import *result = PyObject_New(struct _Import, &Py_Import_Type);
        if (result == NULL)
                return NULL;
        if (names == NULL)
                names = PyList_New(0);
        Py_INCREF(names);
        result->names = names;
        result->_base._kind = Import_kind;
        result->_base.lineno = lineno;
        return (PyObject*)result;
}

static void
Import_dealloc(PyObject* _self)
{
        struct _Import *self = (struct _Import*)_self;
        Py_DECREF(self->names);
        PyObject_Del(self);
}

PyTypeObject Py_Import_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "Import",		/*tp_name*/
        sizeof(struct _Import),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        Import_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

static int
Import_validate(PyObject *_obj)
{
        struct _Import *obj = (struct _Import*)_obj;
        int i;
        if (!PyList_Check(obj->names)) {
           failed_check("names", "list", obj->names);
           return -1;
        }
        for(i = 0; i < PyList_Size(obj->names); i++) {
                if (!alias_Check(PyList_GET_ITEM(obj->names, i))) {
                    failed_check("names", "alias", PyList_GET_ITEM(obj->names,
                                 i));
                    return -1;
                }
                if (alias_validate(PyList_GET_ITEM(obj->names, i)) < 0)
                    return -1;
        }
        return 0;
}

PyObject*
Py_ImportFrom_New(PyObject* module, PyObject* names, int lineno)
{
        struct _ImportFrom *result = PyObject_New(struct _ImportFrom, &Py_ImportFrom_Type);
        if (result == NULL)
                return NULL;
        Py_INCREF(module);
        result->module = module;
        if (names == NULL)
                names = PyList_New(0);
        Py_INCREF(names);
        result->names = names;
        result->_base._kind = ImportFrom_kind;
        result->_base.lineno = lineno;
        return (PyObject*)result;
}

static void
ImportFrom_dealloc(PyObject* _self)
{
        struct _ImportFrom *self = (struct _ImportFrom*)_self;
        Py_DECREF(self->module);
        Py_DECREF(self->names);
        PyObject_Del(self);
}

PyTypeObject Py_ImportFrom_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "ImportFrom",		/*tp_name*/
        sizeof(struct _ImportFrom),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        ImportFrom_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

static int
ImportFrom_validate(PyObject *_obj)
{
        struct _ImportFrom *obj = (struct _ImportFrom*)_obj;
        int i;
        if (!PyString_Check(obj->module)) {
            failed_check("module", "identifier", obj->module);
            return -1;
        }
        if (!PyList_Check(obj->names)) {
           failed_check("names", "list", obj->names);
           return -1;
        }
        for(i = 0; i < PyList_Size(obj->names); i++) {
                if (!alias_Check(PyList_GET_ITEM(obj->names, i))) {
                    failed_check("names", "alias", PyList_GET_ITEM(obj->names,
                                 i));
                    return -1;
                }
                if (alias_validate(PyList_GET_ITEM(obj->names, i)) < 0)
                    return -1;
        }
        return 0;
}

PyObject*
Py_Exec_New(PyObject* body, PyObject* globals, PyObject* locals, int lineno)
{
        struct _Exec *result = PyObject_New(struct _Exec, &Py_Exec_Type);
        if (result == NULL)
                return NULL;
        Py_INCREF(body);
        result->body = body;
        if (globals == NULL) {
                Py_INCREF(Py_None);
                globals = Py_None;
        }
        Py_INCREF(globals);
        result->globals = globals;
        if (locals == NULL) {
                Py_INCREF(Py_None);
                locals = Py_None;
        }
        Py_INCREF(locals);
        result->locals = locals;
        result->_base._kind = Exec_kind;
        result->_base.lineno = lineno;
        return (PyObject*)result;
}

static void
Exec_dealloc(PyObject* _self)
{
        struct _Exec *self = (struct _Exec*)_self;
        Py_DECREF(self->body);
        Py_DECREF(self->globals);
        Py_DECREF(self->locals);
        PyObject_Del(self);
}

PyTypeObject Py_Exec_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "Exec",		/*tp_name*/
        sizeof(struct _Exec),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        Exec_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

static int
Exec_validate(PyObject *_obj)
{
        struct _Exec *obj = (struct _Exec*)_obj;
        if (!expr_Check(obj->body)) {
            failed_check("body", "expr", obj->body);
            return -1;
        }
        if (obj->globals == Py_None) /* empty */;
        else if (!expr_Check(obj->globals)) {
            failed_check("globals", "expr", obj->globals);
            return -1;
        }
        else if (expr_validate(obj->globals) < 0)
            return -1;
        if (obj->locals == Py_None) /* empty */;
        else if (!expr_Check(obj->locals)) {
            failed_check("locals", "expr", obj->locals);
            return -1;
        }
        else if (expr_validate(obj->locals) < 0)
            return -1;
        return 0;
}

PyObject*
Py_Global_New(PyObject* names, int lineno)
{
        struct _Global *result = PyObject_New(struct _Global, &Py_Global_Type);
        if (result == NULL)
                return NULL;
        if (names == NULL)
                names = PyList_New(0);
        Py_INCREF(names);
        result->names = names;
        result->_base._kind = Global_kind;
        result->_base.lineno = lineno;
        return (PyObject*)result;
}

static void
Global_dealloc(PyObject* _self)
{
        struct _Global *self = (struct _Global*)_self;
        Py_DECREF(self->names);
        PyObject_Del(self);
}

PyTypeObject Py_Global_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "Global",		/*tp_name*/
        sizeof(struct _Global),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        Global_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

static int
Global_validate(PyObject *_obj)
{
        struct _Global *obj = (struct _Global*)_obj;
        int i;
        if (!PyList_Check(obj->names)) {
           failed_check("names", "list", obj->names);
           return -1;
        }
        for(i = 0; i < PyList_Size(obj->names); i++) {
                if (!PyString_Check(PyList_GET_ITEM(obj->names, i))) {
                    failed_check("names", "identifier",
                                 PyList_GET_ITEM(obj->names, i));
                    return -1;
                }
        }
        return 0;
}

PyObject*
Py_Expr_New(PyObject* value, int lineno)
{
        struct _Expr *result = PyObject_New(struct _Expr, &Py_Expr_Type);
        if (result == NULL)
                return NULL;
        Py_INCREF(value);
        result->value = value;
        result->_base._kind = Expr_kind;
        result->_base.lineno = lineno;
        return (PyObject*)result;
}

static void
Expr_dealloc(PyObject* _self)
{
        struct _Expr *self = (struct _Expr*)_self;
        Py_DECREF(self->value);
        PyObject_Del(self);
}

PyTypeObject Py_Expr_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "Expr",		/*tp_name*/
        sizeof(struct _Expr),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        Expr_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

static int
Expr_validate(PyObject *_obj)
{
        struct _Expr *obj = (struct _Expr*)_obj;
        if (!expr_Check(obj->value)) {
            failed_check("value", "expr", obj->value);
            return -1;
        }
        return 0;
}

PyObject*
Py_Pass_New(int lineno)
{
        struct _Pass *result = PyObject_New(struct _Pass, &Py_Pass_Type);
        if (result == NULL)
                return NULL;
        result->_base._kind = Pass_kind;
        result->_base.lineno = lineno;
        return (PyObject*)result;
}

static void
Pass_dealloc(PyObject* _self)
{
        struct _Pass *self = (struct _Pass*)_self;
        PyObject_Del(self);
}

PyTypeObject Py_Pass_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "Pass",		/*tp_name*/
        sizeof(struct _Pass),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        Pass_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

static int
Pass_validate(PyObject *_obj)
{
        return 0;
}

PyObject*
Py_Break_New(int lineno)
{
        struct _Break *result = PyObject_New(struct _Break, &Py_Break_Type);
        if (result == NULL)
                return NULL;
        result->_base._kind = Break_kind;
        result->_base.lineno = lineno;
        return (PyObject*)result;
}

static void
Break_dealloc(PyObject* _self)
{
        struct _Break *self = (struct _Break*)_self;
        PyObject_Del(self);
}

PyTypeObject Py_Break_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "Break",		/*tp_name*/
        sizeof(struct _Break),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        Break_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

static int
Break_validate(PyObject *_obj)
{
        return 0;
}

PyObject*
Py_Continue_New(int lineno)
{
        struct _Continue *result = PyObject_New(struct _Continue, &Py_Continue_Type);
        if (result == NULL)
                return NULL;
        result->_base._kind = Continue_kind;
        result->_base.lineno = lineno;
        return (PyObject*)result;
}

static void
Continue_dealloc(PyObject* _self)
{
        struct _Continue *self = (struct _Continue*)_self;
        PyObject_Del(self);
}

PyTypeObject Py_Continue_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "Continue",		/*tp_name*/
        sizeof(struct _Continue),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        Continue_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

static int
Continue_validate(PyObject *_obj)
{
        return 0;
}

#define expr_dealloc 0
PyTypeObject Py_expr_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "expr",		/*tp_name*/
        sizeof(struct _expr),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        expr_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

int
expr_validate(PyObject* _obj)
{
        struct _expr *obj = (struct _expr*)_obj;
        assert(expr_Check(_obj));
        switch(obj->_kind) {
                case BoolOp_kind:
                    return BoolOp_validate(_obj);
                case BinOp_kind:
                    return BinOp_validate(_obj);
                case UnaryOp_kind:
                    return UnaryOp_validate(_obj);
                case Lambda_kind:
                    return Lambda_validate(_obj);
                case Dict_kind:
                    return Dict_validate(_obj);
                case ListComp_kind:
                    return ListComp_validate(_obj);
                case GeneratorExp_kind:
                    return GeneratorExp_validate(_obj);
                case Yield_kind:
                    return Yield_validate(_obj);
                case Compare_kind:
                    return Compare_validate(_obj);
                case Call_kind:
                    return Call_validate(_obj);
                case Repr_kind:
                    return Repr_validate(_obj);
                case Num_kind:
                    return Num_validate(_obj);
                case Str_kind:
                    return Str_validate(_obj);
                case Attribute_kind:
                    return Attribute_validate(_obj);
                case Subscript_kind:
                    return Subscript_validate(_obj);
                case Name_kind:
                    return Name_validate(_obj);
                case List_kind:
                    return List_validate(_obj);
                case Tuple_kind:
                    return Tuple_validate(_obj);
        }
        PyErr_SetString(PyExc_TypeError, "invalid _kind in expr");
        return -1;
}
PyObject*
Py_BoolOp_New(PyObject* op, PyObject* values, int lineno)
{
        struct _BoolOp *result = PyObject_New(struct _BoolOp, &Py_BoolOp_Type);
        if (result == NULL)
                return NULL;
        Py_INCREF(op);
        result->op = op;
        if (values == NULL)
                values = PyList_New(0);
        Py_INCREF(values);
        result->values = values;
        result->_base._kind = BoolOp_kind;
        result->_base.lineno = lineno;
        return (PyObject*)result;
}

static void
BoolOp_dealloc(PyObject* _self)
{
        struct _BoolOp *self = (struct _BoolOp*)_self;
        Py_DECREF(self->op);
        Py_DECREF(self->values);
        PyObject_Del(self);
}

PyTypeObject Py_BoolOp_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "BoolOp",		/*tp_name*/
        sizeof(struct _BoolOp),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        BoolOp_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

static int
BoolOp_validate(PyObject *_obj)
{
        struct _BoolOp *obj = (struct _BoolOp*)_obj;
        int i;
        if (!boolop_Check(obj->op)) {
            failed_check("op", "boolop", obj->op);
            return -1;
        }
        if (!PyList_Check(obj->values)) {
           failed_check("values", "list", obj->values);
           return -1;
        }
        for(i = 0; i < PyList_Size(obj->values); i++) {
                if (!expr_Check(PyList_GET_ITEM(obj->values, i))) {
                    failed_check("values", "expr", PyList_GET_ITEM(obj->values,
                                 i));
                    return -1;
                }
                if (expr_validate(PyList_GET_ITEM(obj->values, i)) < 0)
                    return -1;
        }
        return 0;
}

PyObject*
Py_BinOp_New(PyObject* left, PyObject* op, PyObject* right, int lineno)
{
        struct _BinOp *result = PyObject_New(struct _BinOp, &Py_BinOp_Type);
        if (result == NULL)
                return NULL;
        Py_INCREF(left);
        result->left = left;
        Py_INCREF(op);
        result->op = op;
        Py_INCREF(right);
        result->right = right;
        result->_base._kind = BinOp_kind;
        result->_base.lineno = lineno;
        return (PyObject*)result;
}

static void
BinOp_dealloc(PyObject* _self)
{
        struct _BinOp *self = (struct _BinOp*)_self;
        Py_DECREF(self->left);
        Py_DECREF(self->op);
        Py_DECREF(self->right);
        PyObject_Del(self);
}

PyTypeObject Py_BinOp_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "BinOp",		/*tp_name*/
        sizeof(struct _BinOp),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        BinOp_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

static int
BinOp_validate(PyObject *_obj)
{
        struct _BinOp *obj = (struct _BinOp*)_obj;
        if (!expr_Check(obj->left)) {
            failed_check("left", "expr", obj->left);
            return -1;
        }
        if (!operator_Check(obj->op)) {
            failed_check("op", "operator", obj->op);
            return -1;
        }
        if (!expr_Check(obj->right)) {
            failed_check("right", "expr", obj->right);
            return -1;
        }
        return 0;
}

PyObject*
Py_UnaryOp_New(PyObject* op, PyObject* operand, int lineno)
{
        struct _UnaryOp *result = PyObject_New(struct _UnaryOp, &Py_UnaryOp_Type);
        if (result == NULL)
                return NULL;
        Py_INCREF(op);
        result->op = op;
        Py_INCREF(operand);
        result->operand = operand;
        result->_base._kind = UnaryOp_kind;
        result->_base.lineno = lineno;
        return (PyObject*)result;
}

static void
UnaryOp_dealloc(PyObject* _self)
{
        struct _UnaryOp *self = (struct _UnaryOp*)_self;
        Py_DECREF(self->op);
        Py_DECREF(self->operand);
        PyObject_Del(self);
}

PyTypeObject Py_UnaryOp_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "UnaryOp",		/*tp_name*/
        sizeof(struct _UnaryOp),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        UnaryOp_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

static int
UnaryOp_validate(PyObject *_obj)
{
        struct _UnaryOp *obj = (struct _UnaryOp*)_obj;
        if (!unaryop_Check(obj->op)) {
            failed_check("op", "unaryop", obj->op);
            return -1;
        }
        if (!expr_Check(obj->operand)) {
            failed_check("operand", "expr", obj->operand);
            return -1;
        }
        return 0;
}

PyObject*
Py_Lambda_New(PyObject* args, PyObject* body, int lineno)
{
        struct _Lambda *result = PyObject_New(struct _Lambda, &Py_Lambda_Type);
        if (result == NULL)
                return NULL;
        Py_INCREF(args);
        result->args = args;
        Py_INCREF(body);
        result->body = body;
        result->_base._kind = Lambda_kind;
        result->_base.lineno = lineno;
        return (PyObject*)result;
}

static void
Lambda_dealloc(PyObject* _self)
{
        struct _Lambda *self = (struct _Lambda*)_self;
        Py_DECREF(self->args);
        Py_DECREF(self->body);
        PyObject_Del(self);
}

PyTypeObject Py_Lambda_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "Lambda",		/*tp_name*/
        sizeof(struct _Lambda),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        Lambda_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

static int
Lambda_validate(PyObject *_obj)
{
        struct _Lambda *obj = (struct _Lambda*)_obj;
        if (!arguments_Check(obj->args)) {
            failed_check("args", "arguments", obj->args);
            return -1;
        }
        if (!expr_Check(obj->body)) {
            failed_check("body", "expr", obj->body);
            return -1;
        }
        return 0;
}

PyObject*
Py_Dict_New(PyObject* keys, PyObject* values, int lineno)
{
        struct _Dict *result = PyObject_New(struct _Dict, &Py_Dict_Type);
        if (result == NULL)
                return NULL;
        if (keys == NULL)
                keys = PyList_New(0);
        Py_INCREF(keys);
        result->keys = keys;
        if (values == NULL)
                values = PyList_New(0);
        Py_INCREF(values);
        result->values = values;
        result->_base._kind = Dict_kind;
        result->_base.lineno = lineno;
        return (PyObject*)result;
}

static void
Dict_dealloc(PyObject* _self)
{
        struct _Dict *self = (struct _Dict*)_self;
        Py_DECREF(self->keys);
        Py_DECREF(self->values);
        PyObject_Del(self);
}

PyTypeObject Py_Dict_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "Dict",		/*tp_name*/
        sizeof(struct _Dict),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        Dict_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

static int
Dict_validate(PyObject *_obj)
{
        struct _Dict *obj = (struct _Dict*)_obj;
        int i;
        if (!PyList_Check(obj->keys)) {
           failed_check("keys", "list", obj->keys);
           return -1;
        }
        for(i = 0; i < PyList_Size(obj->keys); i++) {
                if (!expr_Check(PyList_GET_ITEM(obj->keys, i))) {
                    failed_check("keys", "expr", PyList_GET_ITEM(obj->keys, i));
                    return -1;
                }
                if (expr_validate(PyList_GET_ITEM(obj->keys, i)) < 0)
                    return -1;
        }
        if (!PyList_Check(obj->values)) {
           failed_check("values", "list", obj->values);
           return -1;
        }
        for(i = 0; i < PyList_Size(obj->values); i++) {
                if (!expr_Check(PyList_GET_ITEM(obj->values, i))) {
                    failed_check("values", "expr", PyList_GET_ITEM(obj->values,
                                 i));
                    return -1;
                }
                if (expr_validate(PyList_GET_ITEM(obj->values, i)) < 0)
                    return -1;
        }
        return 0;
}

PyObject*
Py_ListComp_New(PyObject* elt, PyObject* generators, int lineno)
{
        struct _ListComp *result = PyObject_New(struct _ListComp, &Py_ListComp_Type);
        if (result == NULL)
                return NULL;
        Py_INCREF(elt);
        result->elt = elt;
        if (generators == NULL)
                generators = PyList_New(0);
        Py_INCREF(generators);
        result->generators = generators;
        result->_base._kind = ListComp_kind;
        result->_base.lineno = lineno;
        return (PyObject*)result;
}

static void
ListComp_dealloc(PyObject* _self)
{
        struct _ListComp *self = (struct _ListComp*)_self;
        Py_DECREF(self->elt);
        Py_DECREF(self->generators);
        PyObject_Del(self);
}

PyTypeObject Py_ListComp_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "ListComp",		/*tp_name*/
        sizeof(struct _ListComp),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        ListComp_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

static int
ListComp_validate(PyObject *_obj)
{
        struct _ListComp *obj = (struct _ListComp*)_obj;
        int i;
        if (!expr_Check(obj->elt)) {
            failed_check("elt", "expr", obj->elt);
            return -1;
        }
        if (!PyList_Check(obj->generators)) {
           failed_check("generators", "list", obj->generators);
           return -1;
        }
        for(i = 0; i < PyList_Size(obj->generators); i++) {
                if (!comprehension_Check(PyList_GET_ITEM(obj->generators, i))) {
                    failed_check("generators", "comprehension",
                                 PyList_GET_ITEM(obj->generators, i));
                    return -1;
                }
                if (comprehension_validate(PyList_GET_ITEM(obj->generators, i))
                    < 0)
                    return -1;
        }
        return 0;
}

PyObject*
Py_GeneratorExp_New(PyObject* elt, PyObject* generators, int lineno)
{
        struct _GeneratorExp *result = PyObject_New(struct _GeneratorExp, &Py_GeneratorExp_Type);
        if (result == NULL)
                return NULL;
        Py_INCREF(elt);
        result->elt = elt;
        if (generators == NULL)
                generators = PyList_New(0);
        Py_INCREF(generators);
        result->generators = generators;
        result->_base._kind = GeneratorExp_kind;
        result->_base.lineno = lineno;
        return (PyObject*)result;
}

static void
GeneratorExp_dealloc(PyObject* _self)
{
        struct _GeneratorExp *self = (struct _GeneratorExp*)_self;
        Py_DECREF(self->elt);
        Py_DECREF(self->generators);
        PyObject_Del(self);
}

PyTypeObject Py_GeneratorExp_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "GeneratorExp",		/*tp_name*/
        sizeof(struct _GeneratorExp),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        GeneratorExp_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

static int
GeneratorExp_validate(PyObject *_obj)
{
        struct _GeneratorExp *obj = (struct _GeneratorExp*)_obj;
        int i;
        if (!expr_Check(obj->elt)) {
            failed_check("elt", "expr", obj->elt);
            return -1;
        }
        if (!PyList_Check(obj->generators)) {
           failed_check("generators", "list", obj->generators);
           return -1;
        }
        for(i = 0; i < PyList_Size(obj->generators); i++) {
                if (!comprehension_Check(PyList_GET_ITEM(obj->generators, i))) {
                    failed_check("generators", "comprehension",
                                 PyList_GET_ITEM(obj->generators, i));
                    return -1;
                }
                if (comprehension_validate(PyList_GET_ITEM(obj->generators, i))
                    < 0)
                    return -1;
        }
        return 0;
}

PyObject*
Py_Yield_New(PyObject* value, int lineno)
{
        struct _Yield *result = PyObject_New(struct _Yield, &Py_Yield_Type);
        if (result == NULL)
                return NULL;
        if (value == NULL) {
                Py_INCREF(Py_None);
                value = Py_None;
        }
        Py_INCREF(value);
        result->value = value;
        result->_base._kind = Yield_kind;
        result->_base.lineno = lineno;
        return (PyObject*)result;
}

static void
Yield_dealloc(PyObject* _self)
{
        struct _Yield *self = (struct _Yield*)_self;
        Py_DECREF(self->value);
        PyObject_Del(self);
}

PyTypeObject Py_Yield_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "Yield",		/*tp_name*/
        sizeof(struct _Yield),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        Yield_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

static int
Yield_validate(PyObject *_obj)
{
        struct _Yield *obj = (struct _Yield*)_obj;
        if (obj->value == Py_None) /* empty */;
        else if (!expr_Check(obj->value)) {
            failed_check("value", "expr", obj->value);
            return -1;
        }
        else if (expr_validate(obj->value) < 0)
            return -1;
        return 0;
}

PyObject*
Py_Compare_New(PyObject* left, PyObject* ops, PyObject* comparators, int lineno)
{
        struct _Compare *result = PyObject_New(struct _Compare, &Py_Compare_Type);
        if (result == NULL)
                return NULL;
        Py_INCREF(left);
        result->left = left;
        if (ops == NULL)
                ops = PyList_New(0);
        Py_INCREF(ops);
        result->ops = ops;
        if (comparators == NULL)
                comparators = PyList_New(0);
        Py_INCREF(comparators);
        result->comparators = comparators;
        result->_base._kind = Compare_kind;
        result->_base.lineno = lineno;
        return (PyObject*)result;
}

static void
Compare_dealloc(PyObject* _self)
{
        struct _Compare *self = (struct _Compare*)_self;
        Py_DECREF(self->left);
        Py_DECREF(self->ops);
        Py_DECREF(self->comparators);
        PyObject_Del(self);
}

PyTypeObject Py_Compare_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "Compare",		/*tp_name*/
        sizeof(struct _Compare),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        Compare_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

static int
Compare_validate(PyObject *_obj)
{
        struct _Compare *obj = (struct _Compare*)_obj;
        int i;
        if (!expr_Check(obj->left)) {
            failed_check("left", "expr", obj->left);
            return -1;
        }
        if (!PyList_Check(obj->ops)) {
           failed_check("ops", "list", obj->ops);
           return -1;
        }
        for(i = 0; i < PyList_Size(obj->ops); i++) {
                if (!cmpop_Check(PyList_GET_ITEM(obj->ops, i))) {
                    failed_check("ops", "cmpop", PyList_GET_ITEM(obj->ops, i));
                    return -1;
                }
                if (cmpop_validate(PyList_GET_ITEM(obj->ops, i)) < 0)
                    return -1;
        }
        if (!PyList_Check(obj->comparators)) {
           failed_check("comparators", "list", obj->comparators);
           return -1;
        }
        for(i = 0; i < PyList_Size(obj->comparators); i++) {
                if (!expr_Check(PyList_GET_ITEM(obj->comparators, i))) {
                    failed_check("comparators", "expr",
                                 PyList_GET_ITEM(obj->comparators, i));
                    return -1;
                }
                if (expr_validate(PyList_GET_ITEM(obj->comparators, i)) < 0)
                    return -1;
        }
        return 0;
}

PyObject*
Py_Call_New(PyObject* func, PyObject* args, PyObject* keywords, PyObject*
            starargs, PyObject* kwargs, int lineno)
{
        struct _Call *result = PyObject_New(struct _Call, &Py_Call_Type);
        if (result == NULL)
                return NULL;
        Py_INCREF(func);
        result->func = func;
        if (args == NULL)
                args = PyList_New(0);
        Py_INCREF(args);
        result->args = args;
        if (keywords == NULL)
                keywords = PyList_New(0);
        Py_INCREF(keywords);
        result->keywords = keywords;
        if (starargs == NULL) {
                Py_INCREF(Py_None);
                starargs = Py_None;
        }
        Py_INCREF(starargs);
        result->starargs = starargs;
        if (kwargs == NULL) {
                Py_INCREF(Py_None);
                kwargs = Py_None;
        }
        Py_INCREF(kwargs);
        result->kwargs = kwargs;
        result->_base._kind = Call_kind;
        result->_base.lineno = lineno;
        return (PyObject*)result;
}

static void
Call_dealloc(PyObject* _self)
{
        struct _Call *self = (struct _Call*)_self;
        Py_DECREF(self->func);
        Py_DECREF(self->args);
        Py_DECREF(self->keywords);
        Py_DECREF(self->starargs);
        Py_DECREF(self->kwargs);
        PyObject_Del(self);
}

PyTypeObject Py_Call_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "Call",		/*tp_name*/
        sizeof(struct _Call),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        Call_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

static int
Call_validate(PyObject *_obj)
{
        struct _Call *obj = (struct _Call*)_obj;
        int i;
        if (!expr_Check(obj->func)) {
            failed_check("func", "expr", obj->func);
            return -1;
        }
        if (!PyList_Check(obj->args)) {
           failed_check("args", "list", obj->args);
           return -1;
        }
        for(i = 0; i < PyList_Size(obj->args); i++) {
                if (!expr_Check(PyList_GET_ITEM(obj->args, i))) {
                    failed_check("args", "expr", PyList_GET_ITEM(obj->args, i));
                    return -1;
                }
                if (expr_validate(PyList_GET_ITEM(obj->args, i)) < 0)
                    return -1;
        }
        if (!PyList_Check(obj->keywords)) {
           failed_check("keywords", "list", obj->keywords);
           return -1;
        }
        for(i = 0; i < PyList_Size(obj->keywords); i++) {
                if (!keyword_Check(PyList_GET_ITEM(obj->keywords, i))) {
                    failed_check("keywords", "keyword",
                                 PyList_GET_ITEM(obj->keywords, i));
                    return -1;
                }
                if (keyword_validate(PyList_GET_ITEM(obj->keywords, i)) < 0)
                    return -1;
        }
        if (obj->starargs == Py_None) /* empty */;
        else if (!expr_Check(obj->starargs)) {
            failed_check("starargs", "expr", obj->starargs);
            return -1;
        }
        else if (expr_validate(obj->starargs) < 0)
            return -1;
        if (obj->kwargs == Py_None) /* empty */;
        else if (!expr_Check(obj->kwargs)) {
            failed_check("kwargs", "expr", obj->kwargs);
            return -1;
        }
        else if (expr_validate(obj->kwargs) < 0)
            return -1;
        return 0;
}

PyObject*
Py_Repr_New(PyObject* value, int lineno)
{
        struct _Repr *result = PyObject_New(struct _Repr, &Py_Repr_Type);
        if (result == NULL)
                return NULL;
        Py_INCREF(value);
        result->value = value;
        result->_base._kind = Repr_kind;
        result->_base.lineno = lineno;
        return (PyObject*)result;
}

static void
Repr_dealloc(PyObject* _self)
{
        struct _Repr *self = (struct _Repr*)_self;
        Py_DECREF(self->value);
        PyObject_Del(self);
}

PyTypeObject Py_Repr_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "Repr",		/*tp_name*/
        sizeof(struct _Repr),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        Repr_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

static int
Repr_validate(PyObject *_obj)
{
        struct _Repr *obj = (struct _Repr*)_obj;
        if (!expr_Check(obj->value)) {
            failed_check("value", "expr", obj->value);
            return -1;
        }
        return 0;
}

PyObject*
Py_Num_New(PyObject* n, int lineno)
{
        struct _Num *result = PyObject_New(struct _Num, &Py_Num_Type);
        if (result == NULL)
                return NULL;
        Py_INCREF(n);
        result->n = n;
        result->_base._kind = Num_kind;
        result->_base.lineno = lineno;
        return (PyObject*)result;
}

static void
Num_dealloc(PyObject* _self)
{
        struct _Num *self = (struct _Num*)_self;
        Py_DECREF(self->n);
        PyObject_Del(self);
}

PyTypeObject Py_Num_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "Num",		/*tp_name*/
        sizeof(struct _Num),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        Num_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

static int
Num_validate(PyObject *_obj)
{
        struct _Num *obj = (struct _Num*)_obj;
        if (!object_Check(obj->n)) {
            failed_check("n", "object", obj->n);
            return -1;
        }
        return 0;
}

PyObject*
Py_Str_New(PyObject* s, int lineno)
{
        struct _Str *result = PyObject_New(struct _Str, &Py_Str_Type);
        if (result == NULL)
                return NULL;
        Py_INCREF(s);
        result->s = s;
        result->_base._kind = Str_kind;
        result->_base.lineno = lineno;
        return (PyObject*)result;
}

static void
Str_dealloc(PyObject* _self)
{
        struct _Str *self = (struct _Str*)_self;
        Py_DECREF(self->s);
        PyObject_Del(self);
}

PyTypeObject Py_Str_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "Str",		/*tp_name*/
        sizeof(struct _Str),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        Str_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

static int
Str_validate(PyObject *_obj)
{
        struct _Str *obj = (struct _Str*)_obj;
        if (!PyString_Check(obj->s)) {
            failed_check("s", "string", obj->s);
            return -1;
        }
        return 0;
}

PyObject*
Py_Attribute_New(PyObject* value, PyObject* attr, PyObject* ctx, int lineno)
{
        struct _Attribute *result = PyObject_New(struct _Attribute, &Py_Attribute_Type);
        if (result == NULL)
                return NULL;
        Py_INCREF(value);
        result->value = value;
        Py_INCREF(attr);
        result->attr = attr;
        Py_INCREF(ctx);
        result->ctx = ctx;
        result->_base._kind = Attribute_kind;
        result->_base.lineno = lineno;
        return (PyObject*)result;
}

static void
Attribute_dealloc(PyObject* _self)
{
        struct _Attribute *self = (struct _Attribute*)_self;
        Py_DECREF(self->value);
        Py_DECREF(self->attr);
        Py_DECREF(self->ctx);
        PyObject_Del(self);
}

PyTypeObject Py_Attribute_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "Attribute",		/*tp_name*/
        sizeof(struct _Attribute),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        Attribute_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

static int
Attribute_validate(PyObject *_obj)
{
        struct _Attribute *obj = (struct _Attribute*)_obj;
        if (!expr_Check(obj->value)) {
            failed_check("value", "expr", obj->value);
            return -1;
        }
        if (!PyString_Check(obj->attr)) {
            failed_check("attr", "identifier", obj->attr);
            return -1;
        }
        if (!expr_context_Check(obj->ctx)) {
            failed_check("ctx", "expr_context", obj->ctx);
            return -1;
        }
        return 0;
}

PyObject*
Py_Subscript_New(PyObject* value, PyObject* slice, PyObject* ctx, int lineno)
{
        struct _Subscript *result = PyObject_New(struct _Subscript, &Py_Subscript_Type);
        if (result == NULL)
                return NULL;
        Py_INCREF(value);
        result->value = value;
        Py_INCREF(slice);
        result->slice = slice;
        Py_INCREF(ctx);
        result->ctx = ctx;
        result->_base._kind = Subscript_kind;
        result->_base.lineno = lineno;
        return (PyObject*)result;
}

static void
Subscript_dealloc(PyObject* _self)
{
        struct _Subscript *self = (struct _Subscript*)_self;
        Py_DECREF(self->value);
        Py_DECREF(self->slice);
        Py_DECREF(self->ctx);
        PyObject_Del(self);
}

PyTypeObject Py_Subscript_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "Subscript",		/*tp_name*/
        sizeof(struct _Subscript),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        Subscript_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

static int
Subscript_validate(PyObject *_obj)
{
        struct _Subscript *obj = (struct _Subscript*)_obj;
        if (!expr_Check(obj->value)) {
            failed_check("value", "expr", obj->value);
            return -1;
        }
        if (!slice_Check(obj->slice)) {
            failed_check("slice", "slice", obj->slice);
            return -1;
        }
        if (!expr_context_Check(obj->ctx)) {
            failed_check("ctx", "expr_context", obj->ctx);
            return -1;
        }
        return 0;
}

PyObject*
Py_Name_New(PyObject* id, PyObject* ctx, int lineno)
{
        struct _Name *result = PyObject_New(struct _Name, &Py_Name_Type);
        if (result == NULL)
                return NULL;
        Py_INCREF(id);
        result->id = id;
        Py_INCREF(ctx);
        result->ctx = ctx;
        result->_base._kind = Name_kind;
        result->_base.lineno = lineno;
        return (PyObject*)result;
}

static void
Name_dealloc(PyObject* _self)
{
        struct _Name *self = (struct _Name*)_self;
        Py_DECREF(self->id);
        Py_DECREF(self->ctx);
        PyObject_Del(self);
}

PyTypeObject Py_Name_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "Name",		/*tp_name*/
        sizeof(struct _Name),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        Name_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

static int
Name_validate(PyObject *_obj)
{
        struct _Name *obj = (struct _Name*)_obj;
        if (!PyString_Check(obj->id)) {
            failed_check("id", "identifier", obj->id);
            return -1;
        }
        if (!expr_context_Check(obj->ctx)) {
            failed_check("ctx", "expr_context", obj->ctx);
            return -1;
        }
        return 0;
}

PyObject*
Py_List_New(PyObject* elts, PyObject* ctx, int lineno)
{
        struct _List *result = PyObject_New(struct _List, &Py_List_Type);
        if (result == NULL)
                return NULL;
        if (elts == NULL)
                elts = PyList_New(0);
        Py_INCREF(elts);
        result->elts = elts;
        Py_INCREF(ctx);
        result->ctx = ctx;
        result->_base._kind = List_kind;
        result->_base.lineno = lineno;
        return (PyObject*)result;
}

static void
List_dealloc(PyObject* _self)
{
        struct _List *self = (struct _List*)_self;
        Py_DECREF(self->elts);
        Py_DECREF(self->ctx);
        PyObject_Del(self);
}

PyTypeObject Py_List_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "List",		/*tp_name*/
        sizeof(struct _List),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        List_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

static int
List_validate(PyObject *_obj)
{
        struct _List *obj = (struct _List*)_obj;
        int i;
        if (!PyList_Check(obj->elts)) {
           failed_check("elts", "list", obj->elts);
           return -1;
        }
        for(i = 0; i < PyList_Size(obj->elts); i++) {
                if (!expr_Check(PyList_GET_ITEM(obj->elts, i))) {
                    failed_check("elts", "expr", PyList_GET_ITEM(obj->elts, i));
                    return -1;
                }
                if (expr_validate(PyList_GET_ITEM(obj->elts, i)) < 0)
                    return -1;
        }
        if (!expr_context_Check(obj->ctx)) {
            failed_check("ctx", "expr_context", obj->ctx);
            return -1;
        }
        return 0;
}

PyObject*
Py_Tuple_New(PyObject* elts, PyObject* ctx, int lineno)
{
        struct _Tuple *result = PyObject_New(struct _Tuple, &Py_Tuple_Type);
        if (result == NULL)
                return NULL;
        if (elts == NULL)
                elts = PyList_New(0);
        Py_INCREF(elts);
        result->elts = elts;
        Py_INCREF(ctx);
        result->ctx = ctx;
        result->_base._kind = Tuple_kind;
        result->_base.lineno = lineno;
        return (PyObject*)result;
}

static void
Tuple_dealloc(PyObject* _self)
{
        struct _Tuple *self = (struct _Tuple*)_self;
        Py_DECREF(self->elts);
        Py_DECREF(self->ctx);
        PyObject_Del(self);
}

PyTypeObject Py_Tuple_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "Tuple",		/*tp_name*/
        sizeof(struct _Tuple),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        Tuple_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

static int
Tuple_validate(PyObject *_obj)
{
        struct _Tuple *obj = (struct _Tuple*)_obj;
        int i;
        if (!PyList_Check(obj->elts)) {
           failed_check("elts", "list", obj->elts);
           return -1;
        }
        for(i = 0; i < PyList_Size(obj->elts); i++) {
                if (!expr_Check(PyList_GET_ITEM(obj->elts, i))) {
                    failed_check("elts", "expr", PyList_GET_ITEM(obj->elts, i));
                    return -1;
                }
                if (expr_validate(PyList_GET_ITEM(obj->elts, i)) < 0)
                    return -1;
        }
        if (!expr_context_Check(obj->ctx)) {
            failed_check("ctx", "expr_context", obj->ctx);
            return -1;
        }
        return 0;
}

#define expr_context_dealloc 0
PyTypeObject Py_expr_context_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "expr_context",		/*tp_name*/
        sizeof(struct _expr_context),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        expr_context_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

int
expr_context_validate(PyObject* _obj)
{
        struct _expr_context *obj = (struct _expr_context*)_obj;
        assert(expr_context_Check(_obj));
        switch(obj->_kind) {
                case Load_kind:
                    return Load_validate(_obj);
                case Store_kind:
                    return Store_validate(_obj);
                case Del_kind:
                    return Del_validate(_obj);
                case AugLoad_kind:
                    return AugLoad_validate(_obj);
                case AugStore_kind:
                    return AugStore_validate(_obj);
                case Param_kind:
                    return Param_validate(_obj);
        }
        PyErr_SetString(PyExc_TypeError, "invalid _kind in expr_context");
        return -1;
}
PyObject*
Py_Load_New()
{
        struct _Load *result = PyObject_New(struct _Load, &Py_Load_Type);
        if (result == NULL)
                return NULL;
        result->_base._kind = Load_kind;
        return (PyObject*)result;
}

static void
Load_dealloc(PyObject* _self)
{
        struct _Load *self = (struct _Load*)_self;
        PyObject_Del(self);
}

PyTypeObject Py_Load_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "Load",		/*tp_name*/
        sizeof(struct _Load),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        Load_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

static int
Load_validate(PyObject *_obj)
{
        return 0;
}

PyObject*
Py_Store_New()
{
        struct _Store *result = PyObject_New(struct _Store, &Py_Store_Type);
        if (result == NULL)
                return NULL;
        result->_base._kind = Store_kind;
        return (PyObject*)result;
}

static void
Store_dealloc(PyObject* _self)
{
        struct _Store *self = (struct _Store*)_self;
        PyObject_Del(self);
}

PyTypeObject Py_Store_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "Store",		/*tp_name*/
        sizeof(struct _Store),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        Store_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

static int
Store_validate(PyObject *_obj)
{
        return 0;
}

PyObject*
Py_Del_New()
{
        struct _Del *result = PyObject_New(struct _Del, &Py_Del_Type);
        if (result == NULL)
                return NULL;
        result->_base._kind = Del_kind;
        return (PyObject*)result;
}

static void
Del_dealloc(PyObject* _self)
{
        struct _Del *self = (struct _Del*)_self;
        PyObject_Del(self);
}

PyTypeObject Py_Del_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "Del",		/*tp_name*/
        sizeof(struct _Del),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        Del_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

static int
Del_validate(PyObject *_obj)
{
        return 0;
}

PyObject*
Py_AugLoad_New()
{
        struct _AugLoad *result = PyObject_New(struct _AugLoad, &Py_AugLoad_Type);
        if (result == NULL)
                return NULL;
        result->_base._kind = AugLoad_kind;
        return (PyObject*)result;
}

static void
AugLoad_dealloc(PyObject* _self)
{
        struct _AugLoad *self = (struct _AugLoad*)_self;
        PyObject_Del(self);
}

PyTypeObject Py_AugLoad_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "AugLoad",		/*tp_name*/
        sizeof(struct _AugLoad),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        AugLoad_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

static int
AugLoad_validate(PyObject *_obj)
{
        return 0;
}

PyObject*
Py_AugStore_New()
{
        struct _AugStore *result = PyObject_New(struct _AugStore, &Py_AugStore_Type);
        if (result == NULL)
                return NULL;
        result->_base._kind = AugStore_kind;
        return (PyObject*)result;
}

static void
AugStore_dealloc(PyObject* _self)
{
        struct _AugStore *self = (struct _AugStore*)_self;
        PyObject_Del(self);
}

PyTypeObject Py_AugStore_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "AugStore",		/*tp_name*/
        sizeof(struct _AugStore),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        AugStore_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

static int
AugStore_validate(PyObject *_obj)
{
        return 0;
}

PyObject*
Py_Param_New()
{
        struct _Param *result = PyObject_New(struct _Param, &Py_Param_Type);
        if (result == NULL)
                return NULL;
        result->_base._kind = Param_kind;
        return (PyObject*)result;
}

static void
Param_dealloc(PyObject* _self)
{
        struct _Param *self = (struct _Param*)_self;
        PyObject_Del(self);
}

PyTypeObject Py_Param_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "Param",		/*tp_name*/
        sizeof(struct _Param),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        Param_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

static int
Param_validate(PyObject *_obj)
{
        return 0;
}

#define slice_dealloc 0
PyTypeObject Py_slice_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "slice",		/*tp_name*/
        sizeof(struct _slice),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        slice_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

int
slice_validate(PyObject* _obj)
{
        struct _slice *obj = (struct _slice*)_obj;
        assert(slice_Check(_obj));
        switch(obj->_kind) {
                case Ellipsis_kind:
                    return Ellipsis_validate(_obj);
                case Slice_kind:
                    return Slice_validate(_obj);
                case ExtSlice_kind:
                    return ExtSlice_validate(_obj);
                case Index_kind:
                    return Index_validate(_obj);
        }
        PyErr_SetString(PyExc_TypeError, "invalid _kind in slice");
        return -1;
}
PyObject*
Py_Ellipsis_New()
{
        struct _Ellipsis *result = PyObject_New(struct _Ellipsis, &Py_Ellipsis_Type);
        if (result == NULL)
                return NULL;
        result->_base._kind = Ellipsis_kind;
        return (PyObject*)result;
}

static void
Ellipsis_dealloc(PyObject* _self)
{
        struct _Ellipsis *self = (struct _Ellipsis*)_self;
        PyObject_Del(self);
}

PyTypeObject Py_Ellipsis_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "Ellipsis",		/*tp_name*/
        sizeof(struct _Ellipsis),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        Ellipsis_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

static int
Ellipsis_validate(PyObject *_obj)
{
        return 0;
}

PyObject*
Py_Slice_New(PyObject* lower, PyObject* upper, PyObject* step)
{
        struct _Slice *result = PyObject_New(struct _Slice, &Py_Slice_Type);
        if (result == NULL)
                return NULL;
        if (lower == NULL) {
                Py_INCREF(Py_None);
                lower = Py_None;
        }
        Py_INCREF(lower);
        result->lower = lower;
        if (upper == NULL) {
                Py_INCREF(Py_None);
                upper = Py_None;
        }
        Py_INCREF(upper);
        result->upper = upper;
        if (step == NULL) {
                Py_INCREF(Py_None);
                step = Py_None;
        }
        Py_INCREF(step);
        result->step = step;
        result->_base._kind = Slice_kind;
        return (PyObject*)result;
}

static void
Slice_dealloc(PyObject* _self)
{
        struct _Slice *self = (struct _Slice*)_self;
        Py_DECREF(self->lower);
        Py_DECREF(self->upper);
        Py_DECREF(self->step);
        PyObject_Del(self);
}

PyTypeObject Py_Slice_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "Slice",		/*tp_name*/
        sizeof(struct _Slice),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        Slice_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

static int
Slice_validate(PyObject *_obj)
{
        struct _Slice *obj = (struct _Slice*)_obj;
        if (obj->lower == Py_None) /* empty */;
        else if (!expr_Check(obj->lower)) {
            failed_check("lower", "expr", obj->lower);
            return -1;
        }
        else if (expr_validate(obj->lower) < 0)
            return -1;
        if (obj->upper == Py_None) /* empty */;
        else if (!expr_Check(obj->upper)) {
            failed_check("upper", "expr", obj->upper);
            return -1;
        }
        else if (expr_validate(obj->upper) < 0)
            return -1;
        if (obj->step == Py_None) /* empty */;
        else if (!expr_Check(obj->step)) {
            failed_check("step", "expr", obj->step);
            return -1;
        }
        else if (expr_validate(obj->step) < 0)
            return -1;
        return 0;
}

PyObject*
Py_ExtSlice_New(PyObject* dims)
{
        struct _ExtSlice *result = PyObject_New(struct _ExtSlice, &Py_ExtSlice_Type);
        if (result == NULL)
                return NULL;
        if (dims == NULL)
                dims = PyList_New(0);
        Py_INCREF(dims);
        result->dims = dims;
        result->_base._kind = ExtSlice_kind;
        return (PyObject*)result;
}

static void
ExtSlice_dealloc(PyObject* _self)
{
        struct _ExtSlice *self = (struct _ExtSlice*)_self;
        Py_DECREF(self->dims);
        PyObject_Del(self);
}

PyTypeObject Py_ExtSlice_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "ExtSlice",		/*tp_name*/
        sizeof(struct _ExtSlice),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        ExtSlice_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

static int
ExtSlice_validate(PyObject *_obj)
{
        struct _ExtSlice *obj = (struct _ExtSlice*)_obj;
        int i;
        if (!PyList_Check(obj->dims)) {
           failed_check("dims", "list", obj->dims);
           return -1;
        }
        for(i = 0; i < PyList_Size(obj->dims); i++) {
                if (!slice_Check(PyList_GET_ITEM(obj->dims, i))) {
                    failed_check("dims", "slice", PyList_GET_ITEM(obj->dims,
                                 i));
                    return -1;
                }
                if (slice_validate(PyList_GET_ITEM(obj->dims, i)) < 0)
                    return -1;
        }
        return 0;
}

PyObject*
Py_Index_New(PyObject* value)
{
        struct _Index *result = PyObject_New(struct _Index, &Py_Index_Type);
        if (result == NULL)
                return NULL;
        Py_INCREF(value);
        result->value = value;
        result->_base._kind = Index_kind;
        return (PyObject*)result;
}

static void
Index_dealloc(PyObject* _self)
{
        struct _Index *self = (struct _Index*)_self;
        Py_DECREF(self->value);
        PyObject_Del(self);
}

PyTypeObject Py_Index_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "Index",		/*tp_name*/
        sizeof(struct _Index),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        Index_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

static int
Index_validate(PyObject *_obj)
{
        struct _Index *obj = (struct _Index*)_obj;
        if (!expr_Check(obj->value)) {
            failed_check("value", "expr", obj->value);
            return -1;
        }
        return 0;
}

#define boolop_dealloc 0
PyTypeObject Py_boolop_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "boolop",		/*tp_name*/
        sizeof(struct _boolop),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        boolop_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

int
boolop_validate(PyObject* _obj)
{
        struct _boolop *obj = (struct _boolop*)_obj;
        assert(boolop_Check(_obj));
        switch(obj->_kind) {
                case And_kind:
                    return And_validate(_obj);
                case Or_kind:
                    return Or_validate(_obj);
        }
        PyErr_SetString(PyExc_TypeError, "invalid _kind in boolop");
        return -1;
}
PyObject*
Py_And_New()
{
        struct _And *result = PyObject_New(struct _And, &Py_And_Type);
        if (result == NULL)
                return NULL;
        result->_base._kind = And_kind;
        return (PyObject*)result;
}

static void
And_dealloc(PyObject* _self)
{
        struct _And *self = (struct _And*)_self;
        PyObject_Del(self);
}

PyTypeObject Py_And_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "And",		/*tp_name*/
        sizeof(struct _And),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        And_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

static int
And_validate(PyObject *_obj)
{
        return 0;
}

PyObject*
Py_Or_New()
{
        struct _Or *result = PyObject_New(struct _Or, &Py_Or_Type);
        if (result == NULL)
                return NULL;
        result->_base._kind = Or_kind;
        return (PyObject*)result;
}

static void
Or_dealloc(PyObject* _self)
{
        struct _Or *self = (struct _Or*)_self;
        PyObject_Del(self);
}

PyTypeObject Py_Or_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "Or",		/*tp_name*/
        sizeof(struct _Or),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        Or_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

static int
Or_validate(PyObject *_obj)
{
        return 0;
}

#define operator_dealloc 0
PyTypeObject Py_operator_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "operator",		/*tp_name*/
        sizeof(struct _operator),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        operator_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

int
operator_validate(PyObject* _obj)
{
        struct _operator *obj = (struct _operator*)_obj;
        assert(operator_Check(_obj));
        switch(obj->_kind) {
                case Add_kind:
                    return Add_validate(_obj);
                case Sub_kind:
                    return Sub_validate(_obj);
                case Mult_kind:
                    return Mult_validate(_obj);
                case Div_kind:
                    return Div_validate(_obj);
                case Mod_kind:
                    return Mod_validate(_obj);
                case Pow_kind:
                    return Pow_validate(_obj);
                case LShift_kind:
                    return LShift_validate(_obj);
                case RShift_kind:
                    return RShift_validate(_obj);
                case BitOr_kind:
                    return BitOr_validate(_obj);
                case BitXor_kind:
                    return BitXor_validate(_obj);
                case BitAnd_kind:
                    return BitAnd_validate(_obj);
                case FloorDiv_kind:
                    return FloorDiv_validate(_obj);
        }
        PyErr_SetString(PyExc_TypeError, "invalid _kind in operator");
        return -1;
}
PyObject*
Py_Add_New()
{
        struct _Add *result = PyObject_New(struct _Add, &Py_Add_Type);
        if (result == NULL)
                return NULL;
        result->_base._kind = Add_kind;
        return (PyObject*)result;
}

static void
Add_dealloc(PyObject* _self)
{
        struct _Add *self = (struct _Add*)_self;
        PyObject_Del(self);
}

PyTypeObject Py_Add_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "Add",		/*tp_name*/
        sizeof(struct _Add),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        Add_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

static int
Add_validate(PyObject *_obj)
{
        return 0;
}

PyObject*
Py_Sub_New()
{
        struct _Sub *result = PyObject_New(struct _Sub, &Py_Sub_Type);
        if (result == NULL)
                return NULL;
        result->_base._kind = Sub_kind;
        return (PyObject*)result;
}

static void
Sub_dealloc(PyObject* _self)
{
        struct _Sub *self = (struct _Sub*)_self;
        PyObject_Del(self);
}

PyTypeObject Py_Sub_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "Sub",		/*tp_name*/
        sizeof(struct _Sub),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        Sub_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

static int
Sub_validate(PyObject *_obj)
{
        return 0;
}

PyObject*
Py_Mult_New()
{
        struct _Mult *result = PyObject_New(struct _Mult, &Py_Mult_Type);
        if (result == NULL)
                return NULL;
        result->_base._kind = Mult_kind;
        return (PyObject*)result;
}

static void
Mult_dealloc(PyObject* _self)
{
        struct _Mult *self = (struct _Mult*)_self;
        PyObject_Del(self);
}

PyTypeObject Py_Mult_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "Mult",		/*tp_name*/
        sizeof(struct _Mult),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        Mult_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

static int
Mult_validate(PyObject *_obj)
{
        return 0;
}

PyObject*
Py_Div_New()
{
        struct _Div *result = PyObject_New(struct _Div, &Py_Div_Type);
        if (result == NULL)
                return NULL;
        result->_base._kind = Div_kind;
        return (PyObject*)result;
}

static void
Div_dealloc(PyObject* _self)
{
        struct _Div *self = (struct _Div*)_self;
        PyObject_Del(self);
}

PyTypeObject Py_Div_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "Div",		/*tp_name*/
        sizeof(struct _Div),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        Div_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

static int
Div_validate(PyObject *_obj)
{
        return 0;
}

PyObject*
Py_Mod_New()
{
        struct _Mod *result = PyObject_New(struct _Mod, &Py_Mod_Type);
        if (result == NULL)
                return NULL;
        result->_base._kind = Mod_kind;
        return (PyObject*)result;
}

static void
Mod_dealloc(PyObject* _self)
{
        struct _Mod *self = (struct _Mod*)_self;
        PyObject_Del(self);
}

PyTypeObject Py_Mod_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "Mod",		/*tp_name*/
        sizeof(struct _Mod),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        Mod_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

static int
Mod_validate(PyObject *_obj)
{
        return 0;
}

PyObject*
Py_Pow_New()
{
        struct _Pow *result = PyObject_New(struct _Pow, &Py_Pow_Type);
        if (result == NULL)
                return NULL;
        result->_base._kind = Pow_kind;
        return (PyObject*)result;
}

static void
Pow_dealloc(PyObject* _self)
{
        struct _Pow *self = (struct _Pow*)_self;
        PyObject_Del(self);
}

PyTypeObject Py_Pow_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "Pow",		/*tp_name*/
        sizeof(struct _Pow),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        Pow_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

static int
Pow_validate(PyObject *_obj)
{
        return 0;
}

PyObject*
Py_LShift_New()
{
        struct _LShift *result = PyObject_New(struct _LShift, &Py_LShift_Type);
        if (result == NULL)
                return NULL;
        result->_base._kind = LShift_kind;
        return (PyObject*)result;
}

static void
LShift_dealloc(PyObject* _self)
{
        struct _LShift *self = (struct _LShift*)_self;
        PyObject_Del(self);
}

PyTypeObject Py_LShift_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "LShift",		/*tp_name*/
        sizeof(struct _LShift),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        LShift_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

static int
LShift_validate(PyObject *_obj)
{
        return 0;
}

PyObject*
Py_RShift_New()
{
        struct _RShift *result = PyObject_New(struct _RShift, &Py_RShift_Type);
        if (result == NULL)
                return NULL;
        result->_base._kind = RShift_kind;
        return (PyObject*)result;
}

static void
RShift_dealloc(PyObject* _self)
{
        struct _RShift *self = (struct _RShift*)_self;
        PyObject_Del(self);
}

PyTypeObject Py_RShift_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "RShift",		/*tp_name*/
        sizeof(struct _RShift),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        RShift_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

static int
RShift_validate(PyObject *_obj)
{
        return 0;
}

PyObject*
Py_BitOr_New()
{
        struct _BitOr *result = PyObject_New(struct _BitOr, &Py_BitOr_Type);
        if (result == NULL)
                return NULL;
        result->_base._kind = BitOr_kind;
        return (PyObject*)result;
}

static void
BitOr_dealloc(PyObject* _self)
{
        struct _BitOr *self = (struct _BitOr*)_self;
        PyObject_Del(self);
}

PyTypeObject Py_BitOr_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "BitOr",		/*tp_name*/
        sizeof(struct _BitOr),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        BitOr_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

static int
BitOr_validate(PyObject *_obj)
{
        return 0;
}

PyObject*
Py_BitXor_New()
{
        struct _BitXor *result = PyObject_New(struct _BitXor, &Py_BitXor_Type);
        if (result == NULL)
                return NULL;
        result->_base._kind = BitXor_kind;
        return (PyObject*)result;
}

static void
BitXor_dealloc(PyObject* _self)
{
        struct _BitXor *self = (struct _BitXor*)_self;
        PyObject_Del(self);
}

PyTypeObject Py_BitXor_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "BitXor",		/*tp_name*/
        sizeof(struct _BitXor),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        BitXor_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

static int
BitXor_validate(PyObject *_obj)
{
        return 0;
}

PyObject*
Py_BitAnd_New()
{
        struct _BitAnd *result = PyObject_New(struct _BitAnd, &Py_BitAnd_Type);
        if (result == NULL)
                return NULL;
        result->_base._kind = BitAnd_kind;
        return (PyObject*)result;
}

static void
BitAnd_dealloc(PyObject* _self)
{
        struct _BitAnd *self = (struct _BitAnd*)_self;
        PyObject_Del(self);
}

PyTypeObject Py_BitAnd_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "BitAnd",		/*tp_name*/
        sizeof(struct _BitAnd),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        BitAnd_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

static int
BitAnd_validate(PyObject *_obj)
{
        return 0;
}

PyObject*
Py_FloorDiv_New()
{
        struct _FloorDiv *result = PyObject_New(struct _FloorDiv, &Py_FloorDiv_Type);
        if (result == NULL)
                return NULL;
        result->_base._kind = FloorDiv_kind;
        return (PyObject*)result;
}

static void
FloorDiv_dealloc(PyObject* _self)
{
        struct _FloorDiv *self = (struct _FloorDiv*)_self;
        PyObject_Del(self);
}

PyTypeObject Py_FloorDiv_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "FloorDiv",		/*tp_name*/
        sizeof(struct _FloorDiv),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        FloorDiv_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

static int
FloorDiv_validate(PyObject *_obj)
{
        return 0;
}

#define unaryop_dealloc 0
PyTypeObject Py_unaryop_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "unaryop",		/*tp_name*/
        sizeof(struct _unaryop),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        unaryop_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

int
unaryop_validate(PyObject* _obj)
{
        struct _unaryop *obj = (struct _unaryop*)_obj;
        assert(unaryop_Check(_obj));
        switch(obj->_kind) {
                case Invert_kind:
                    return Invert_validate(_obj);
                case Not_kind:
                    return Not_validate(_obj);
                case UAdd_kind:
                    return UAdd_validate(_obj);
                case USub_kind:
                    return USub_validate(_obj);
        }
        PyErr_SetString(PyExc_TypeError, "invalid _kind in unaryop");
        return -1;
}
PyObject*
Py_Invert_New()
{
        struct _Invert *result = PyObject_New(struct _Invert, &Py_Invert_Type);
        if (result == NULL)
                return NULL;
        result->_base._kind = Invert_kind;
        return (PyObject*)result;
}

static void
Invert_dealloc(PyObject* _self)
{
        struct _Invert *self = (struct _Invert*)_self;
        PyObject_Del(self);
}

PyTypeObject Py_Invert_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "Invert",		/*tp_name*/
        sizeof(struct _Invert),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        Invert_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

static int
Invert_validate(PyObject *_obj)
{
        return 0;
}

PyObject*
Py_Not_New()
{
        struct _Not *result = PyObject_New(struct _Not, &Py_Not_Type);
        if (result == NULL)
                return NULL;
        result->_base._kind = Not_kind;
        return (PyObject*)result;
}

static void
Not_dealloc(PyObject* _self)
{
        struct _Not *self = (struct _Not*)_self;
        PyObject_Del(self);
}

PyTypeObject Py_Not_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "Not",		/*tp_name*/
        sizeof(struct _Not),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        Not_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

static int
Not_validate(PyObject *_obj)
{
        return 0;
}

PyObject*
Py_UAdd_New()
{
        struct _UAdd *result = PyObject_New(struct _UAdd, &Py_UAdd_Type);
        if (result == NULL)
                return NULL;
        result->_base._kind = UAdd_kind;
        return (PyObject*)result;
}

static void
UAdd_dealloc(PyObject* _self)
{
        struct _UAdd *self = (struct _UAdd*)_self;
        PyObject_Del(self);
}

PyTypeObject Py_UAdd_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "UAdd",		/*tp_name*/
        sizeof(struct _UAdd),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        UAdd_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

static int
UAdd_validate(PyObject *_obj)
{
        return 0;
}

PyObject*
Py_USub_New()
{
        struct _USub *result = PyObject_New(struct _USub, &Py_USub_Type);
        if (result == NULL)
                return NULL;
        result->_base._kind = USub_kind;
        return (PyObject*)result;
}

static void
USub_dealloc(PyObject* _self)
{
        struct _USub *self = (struct _USub*)_self;
        PyObject_Del(self);
}

PyTypeObject Py_USub_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "USub",		/*tp_name*/
        sizeof(struct _USub),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        USub_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

static int
USub_validate(PyObject *_obj)
{
        return 0;
}

#define cmpop_dealloc 0
PyTypeObject Py_cmpop_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "cmpop",		/*tp_name*/
        sizeof(struct _cmpop),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        cmpop_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

int
cmpop_validate(PyObject* _obj)
{
        struct _cmpop *obj = (struct _cmpop*)_obj;
        assert(cmpop_Check(_obj));
        switch(obj->_kind) {
                case Eq_kind:
                    return Eq_validate(_obj);
                case NotEq_kind:
                    return NotEq_validate(_obj);
                case Lt_kind:
                    return Lt_validate(_obj);
                case LtE_kind:
                    return LtE_validate(_obj);
                case Gt_kind:
                    return Gt_validate(_obj);
                case GtE_kind:
                    return GtE_validate(_obj);
                case Is_kind:
                    return Is_validate(_obj);
                case IsNot_kind:
                    return IsNot_validate(_obj);
                case In_kind:
                    return In_validate(_obj);
                case NotIn_kind:
                    return NotIn_validate(_obj);
        }
        PyErr_SetString(PyExc_TypeError, "invalid _kind in cmpop");
        return -1;
}
PyObject*
Py_Eq_New()
{
        struct _Eq *result = PyObject_New(struct _Eq, &Py_Eq_Type);
        if (result == NULL)
                return NULL;
        result->_base._kind = Eq_kind;
        return (PyObject*)result;
}

static void
Eq_dealloc(PyObject* _self)
{
        struct _Eq *self = (struct _Eq*)_self;
        PyObject_Del(self);
}

PyTypeObject Py_Eq_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "Eq",		/*tp_name*/
        sizeof(struct _Eq),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        Eq_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

static int
Eq_validate(PyObject *_obj)
{
        return 0;
}

PyObject*
Py_NotEq_New()
{
        struct _NotEq *result = PyObject_New(struct _NotEq, &Py_NotEq_Type);
        if (result == NULL)
                return NULL;
        result->_base._kind = NotEq_kind;
        return (PyObject*)result;
}

static void
NotEq_dealloc(PyObject* _self)
{
        struct _NotEq *self = (struct _NotEq*)_self;
        PyObject_Del(self);
}

PyTypeObject Py_NotEq_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "NotEq",		/*tp_name*/
        sizeof(struct _NotEq),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        NotEq_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

static int
NotEq_validate(PyObject *_obj)
{
        return 0;
}

PyObject*
Py_Lt_New()
{
        struct _Lt *result = PyObject_New(struct _Lt, &Py_Lt_Type);
        if (result == NULL)
                return NULL;
        result->_base._kind = Lt_kind;
        return (PyObject*)result;
}

static void
Lt_dealloc(PyObject* _self)
{
        struct _Lt *self = (struct _Lt*)_self;
        PyObject_Del(self);
}

PyTypeObject Py_Lt_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "Lt",		/*tp_name*/
        sizeof(struct _Lt),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        Lt_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

static int
Lt_validate(PyObject *_obj)
{
        return 0;
}

PyObject*
Py_LtE_New()
{
        struct _LtE *result = PyObject_New(struct _LtE, &Py_LtE_Type);
        if (result == NULL)
                return NULL;
        result->_base._kind = LtE_kind;
        return (PyObject*)result;
}

static void
LtE_dealloc(PyObject* _self)
{
        struct _LtE *self = (struct _LtE*)_self;
        PyObject_Del(self);
}

PyTypeObject Py_LtE_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "LtE",		/*tp_name*/
        sizeof(struct _LtE),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        LtE_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

static int
LtE_validate(PyObject *_obj)
{
        return 0;
}

PyObject*
Py_Gt_New()
{
        struct _Gt *result = PyObject_New(struct _Gt, &Py_Gt_Type);
        if (result == NULL)
                return NULL;
        result->_base._kind = Gt_kind;
        return (PyObject*)result;
}

static void
Gt_dealloc(PyObject* _self)
{
        struct _Gt *self = (struct _Gt*)_self;
        PyObject_Del(self);
}

PyTypeObject Py_Gt_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "Gt",		/*tp_name*/
        sizeof(struct _Gt),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        Gt_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

static int
Gt_validate(PyObject *_obj)
{
        return 0;
}

PyObject*
Py_GtE_New()
{
        struct _GtE *result = PyObject_New(struct _GtE, &Py_GtE_Type);
        if (result == NULL)
                return NULL;
        result->_base._kind = GtE_kind;
        return (PyObject*)result;
}

static void
GtE_dealloc(PyObject* _self)
{
        struct _GtE *self = (struct _GtE*)_self;
        PyObject_Del(self);
}

PyTypeObject Py_GtE_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "GtE",		/*tp_name*/
        sizeof(struct _GtE),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        GtE_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

static int
GtE_validate(PyObject *_obj)
{
        return 0;
}

PyObject*
Py_Is_New()
{
        struct _Is *result = PyObject_New(struct _Is, &Py_Is_Type);
        if (result == NULL)
                return NULL;
        result->_base._kind = Is_kind;
        return (PyObject*)result;
}

static void
Is_dealloc(PyObject* _self)
{
        struct _Is *self = (struct _Is*)_self;
        PyObject_Del(self);
}

PyTypeObject Py_Is_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "Is",		/*tp_name*/
        sizeof(struct _Is),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        Is_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

static int
Is_validate(PyObject *_obj)
{
        return 0;
}

PyObject*
Py_IsNot_New()
{
        struct _IsNot *result = PyObject_New(struct _IsNot, &Py_IsNot_Type);
        if (result == NULL)
                return NULL;
        result->_base._kind = IsNot_kind;
        return (PyObject*)result;
}

static void
IsNot_dealloc(PyObject* _self)
{
        struct _IsNot *self = (struct _IsNot*)_self;
        PyObject_Del(self);
}

PyTypeObject Py_IsNot_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "IsNot",		/*tp_name*/
        sizeof(struct _IsNot),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        IsNot_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

static int
IsNot_validate(PyObject *_obj)
{
        return 0;
}

PyObject*
Py_In_New()
{
        struct _In *result = PyObject_New(struct _In, &Py_In_Type);
        if (result == NULL)
                return NULL;
        result->_base._kind = In_kind;
        return (PyObject*)result;
}

static void
In_dealloc(PyObject* _self)
{
        struct _In *self = (struct _In*)_self;
        PyObject_Del(self);
}

PyTypeObject Py_In_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "In",		/*tp_name*/
        sizeof(struct _In),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        In_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

static int
In_validate(PyObject *_obj)
{
        return 0;
}

PyObject*
Py_NotIn_New()
{
        struct _NotIn *result = PyObject_New(struct _NotIn, &Py_NotIn_Type);
        if (result == NULL)
                return NULL;
        result->_base._kind = NotIn_kind;
        return (PyObject*)result;
}

static void
NotIn_dealloc(PyObject* _self)
{
        struct _NotIn *self = (struct _NotIn*)_self;
        PyObject_Del(self);
}

PyTypeObject Py_NotIn_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "NotIn",		/*tp_name*/
        sizeof(struct _NotIn),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        NotIn_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

static int
NotIn_validate(PyObject *_obj)
{
        return 0;
}

PyObject*
Py_comprehension_New(PyObject* target, PyObject* iter, PyObject* ifs)
{
        struct _comprehension *result = PyObject_New(struct _comprehension, &Py_comprehension_Type);
        if (result == NULL)
                return NULL;
        Py_INCREF(target);
        result->target = target;
        Py_INCREF(iter);
        result->iter = iter;
        if (ifs == NULL)
                ifs = PyList_New(0);
        Py_INCREF(ifs);
        result->ifs = ifs;
        return (PyObject*)result;
}

static void
comprehension_dealloc(PyObject* _self)
{
        struct _comprehension *self = (struct _comprehension*)_self;
        Py_DECREF(self->target);
        Py_DECREF(self->iter);
        Py_DECREF(self->ifs);
        PyObject_Del(self);
}

PyTypeObject Py_comprehension_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "comprehension",		/*tp_name*/
        sizeof(struct _comprehension),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        comprehension_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

static int
comprehension_validate(PyObject *_obj)
{
        struct _comprehension *obj = (struct _comprehension*)_obj;
        int i;
        if (!expr_Check(obj->target)) {
            failed_check("target", "expr", obj->target);
            return -1;
        }
        if (!expr_Check(obj->iter)) {
            failed_check("iter", "expr", obj->iter);
            return -1;
        }
        if (!PyList_Check(obj->ifs)) {
           failed_check("ifs", "list", obj->ifs);
           return -1;
        }
        for(i = 0; i < PyList_Size(obj->ifs); i++) {
                if (!expr_Check(PyList_GET_ITEM(obj->ifs, i))) {
                    failed_check("ifs", "expr", PyList_GET_ITEM(obj->ifs, i));
                    return -1;
                }
                if (expr_validate(PyList_GET_ITEM(obj->ifs, i)) < 0)
                    return -1;
        }
        return 0;
}

PyObject*
Py_excepthandler_New(PyObject* type, PyObject* name, PyObject* body)
{
        struct _excepthandler *result = PyObject_New(struct _excepthandler, &Py_excepthandler_Type);
        if (result == NULL)
                return NULL;
        if (type == NULL) {
                Py_INCREF(Py_None);
                type = Py_None;
        }
        Py_INCREF(type);
        result->type = type;
        if (name == NULL) {
                Py_INCREF(Py_None);
                name = Py_None;
        }
        Py_INCREF(name);
        result->name = name;
        if (body == NULL)
                body = PyList_New(0);
        Py_INCREF(body);
        result->body = body;
        return (PyObject*)result;
}

static void
excepthandler_dealloc(PyObject* _self)
{
        struct _excepthandler *self = (struct _excepthandler*)_self;
        Py_DECREF(self->type);
        Py_DECREF(self->name);
        Py_DECREF(self->body);
        PyObject_Del(self);
}

PyTypeObject Py_excepthandler_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "excepthandler",		/*tp_name*/
        sizeof(struct _excepthandler),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        excepthandler_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

static int
excepthandler_validate(PyObject *_obj)
{
        struct _excepthandler *obj = (struct _excepthandler*)_obj;
        int i;
        if (obj->type == Py_None) /* empty */;
        else if (!expr_Check(obj->type)) {
            failed_check("type", "expr", obj->type);
            return -1;
        }
        else if (expr_validate(obj->type) < 0)
            return -1;
        if (obj->name == Py_None) /* empty */;
        else if (!expr_Check(obj->name)) {
            failed_check("name", "expr", obj->name);
            return -1;
        }
        else if (expr_validate(obj->name) < 0)
            return -1;
        if (!PyList_Check(obj->body)) {
           failed_check("body", "list", obj->body);
           return -1;
        }
        for(i = 0; i < PyList_Size(obj->body); i++) {
                if (!stmt_Check(PyList_GET_ITEM(obj->body, i))) {
                    failed_check("body", "stmt", PyList_GET_ITEM(obj->body, i));
                    return -1;
                }
                if (stmt_validate(PyList_GET_ITEM(obj->body, i)) < 0)
                    return -1;
        }
        return 0;
}

PyObject*
Py_arguments_New(PyObject* args, PyObject* vararg, PyObject* kwarg, PyObject*
                 defaults)
{
        struct _arguments *result = PyObject_New(struct _arguments, &Py_arguments_Type);
        if (result == NULL)
                return NULL;
        if (args == NULL)
                args = PyList_New(0);
        Py_INCREF(args);
        result->args = args;
        if (vararg == NULL) {
                Py_INCREF(Py_None);
                vararg = Py_None;
        }
        Py_INCREF(vararg);
        result->vararg = vararg;
        if (kwarg == NULL) {
                Py_INCREF(Py_None);
                kwarg = Py_None;
        }
        Py_INCREF(kwarg);
        result->kwarg = kwarg;
        if (defaults == NULL)
                defaults = PyList_New(0);
        Py_INCREF(defaults);
        result->defaults = defaults;
        return (PyObject*)result;
}

static void
arguments_dealloc(PyObject* _self)
{
        struct _arguments *self = (struct _arguments*)_self;
        Py_DECREF(self->args);
        Py_DECREF(self->vararg);
        Py_DECREF(self->kwarg);
        Py_DECREF(self->defaults);
        PyObject_Del(self);
}

PyTypeObject Py_arguments_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "arguments",		/*tp_name*/
        sizeof(struct _arguments),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        arguments_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

static int
arguments_validate(PyObject *_obj)
{
        struct _arguments *obj = (struct _arguments*)_obj;
        int i;
        if (!PyList_Check(obj->args)) {
           failed_check("args", "list", obj->args);
           return -1;
        }
        for(i = 0; i < PyList_Size(obj->args); i++) {
                if (!expr_Check(PyList_GET_ITEM(obj->args, i))) {
                    failed_check("args", "expr", PyList_GET_ITEM(obj->args, i));
                    return -1;
                }
                if (expr_validate(PyList_GET_ITEM(obj->args, i)) < 0)
                    return -1;
        }
        if (obj->vararg == Py_None) /* empty */;
        else if (!PyString_Check(obj->vararg)) {
            failed_check("vararg", "identifier", obj->vararg);
            return -1;
        }
        if (obj->kwarg == Py_None) /* empty */;
        else if (!PyString_Check(obj->kwarg)) {
            failed_check("kwarg", "identifier", obj->kwarg);
            return -1;
        }
        if (!PyList_Check(obj->defaults)) {
           failed_check("defaults", "list", obj->defaults);
           return -1;
        }
        for(i = 0; i < PyList_Size(obj->defaults); i++) {
                if (!expr_Check(PyList_GET_ITEM(obj->defaults, i))) {
                    failed_check("defaults", "expr",
                                 PyList_GET_ITEM(obj->defaults, i));
                    return -1;
                }
                if (expr_validate(PyList_GET_ITEM(obj->defaults, i)) < 0)
                    return -1;
        }
        return 0;
}

PyObject*
Py_keyword_New(PyObject* arg, PyObject* value)
{
        struct _keyword *result = PyObject_New(struct _keyword, &Py_keyword_Type);
        if (result == NULL)
                return NULL;
        Py_INCREF(arg);
        result->arg = arg;
        Py_INCREF(value);
        result->value = value;
        return (PyObject*)result;
}

static void
keyword_dealloc(PyObject* _self)
{
        struct _keyword *self = (struct _keyword*)_self;
        Py_DECREF(self->arg);
        Py_DECREF(self->value);
        PyObject_Del(self);
}

PyTypeObject Py_keyword_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "keyword",		/*tp_name*/
        sizeof(struct _keyword),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        keyword_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

static int
keyword_validate(PyObject *_obj)
{
        struct _keyword *obj = (struct _keyword*)_obj;
        if (!PyString_Check(obj->arg)) {
            failed_check("arg", "identifier", obj->arg);
            return -1;
        }
        if (!expr_Check(obj->value)) {
            failed_check("value", "expr", obj->value);
            return -1;
        }
        return 0;
}

PyObject*
Py_alias_New(PyObject* name, PyObject* asname)
{
        struct _alias *result = PyObject_New(struct _alias, &Py_alias_Type);
        if (result == NULL)
                return NULL;
        Py_INCREF(name);
        result->name = name;
        if (asname == NULL) {
                Py_INCREF(Py_None);
                asname = Py_None;
        }
        Py_INCREF(asname);
        result->asname = asname;
        return (PyObject*)result;
}

static void
alias_dealloc(PyObject* _self)
{
        struct _alias *self = (struct _alias*)_self;
        Py_DECREF(self->name);
        Py_DECREF(self->asname);
        PyObject_Del(self);
}

PyTypeObject Py_alias_Type = {
        PyObject_HEAD_INIT(NULL)
        0,		/*ob_size*/
        "alias",		/*tp_name*/
        sizeof(struct _alias),	/*tp_basicsize*/
        0,		/* tp_itemsize */
        alias_dealloc,		/*tp_dealloc*/
        0,		/* tp_print */
        0,		/* tp_getattr */
        0,		/* tp_setattr */
        0,		/* tp_compare */
        0,		/* tp_repr */
        0,		/* tp_as_number */
        0,		/* tp_as_sequence */
        0,		/* tp_as_mapping */
        0,		/* tp_hash */
        0,		/* tp_call */
        0,		/* tp_str */
        0,		/* tp_getattro */
        0,		/* tp_setattro */
        0,		/* tp_as_buffer */
        Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,		/*tp_flags*/
        0,		/* tp_doc */
        0,		/* tp_traverse */
        0,		/* tp_clear */
        0,		/* tp_richcompare */
        0,		/* tp_weaklistoffset */
        0,		/* tp_iter */
        0,		/* tp_iternext */
        0,		/* tp_methods */
        0,		/* tp_members */
        0,		/* tp_getset */
        0,		/* tp_base */
        0,		/* tp_dict */
        0,		/* tp_descr_get */
        0,		/* tp_descr_set */
        0,		/* tp_dictoffset */
        0,		/* tp_init */
        0,		/* tp_alloc */
        0,		/* tp_new */
        0,		/* tp_free */
        0,		/* tp_is_gc */
};

static int
alias_validate(PyObject *_obj)
{
        struct _alias *obj = (struct _alias*)_obj;
        if (!PyString_Check(obj->name)) {
            failed_check("name", "identifier", obj->name);
            return -1;
        }
        if (obj->asname == Py_None) /* empty */;
        else if (!PyString_Check(obj->asname)) {
            failed_check("asname", "identifier", obj->asname);
            return -1;
        }
        return 0;
}


int PyAST_Validate(PyObject *obj)
{
        if (mod_Check(obj))
                return mod_validate(obj);
        if (stmt_Check(obj))
                return stmt_validate(obj);
        if (expr_Check(obj))
                return expr_validate(obj);
        if (expr_context_Check(obj))
                return expr_context_validate(obj);
        if (slice_Check(obj))
                return slice_validate(obj);
        if (boolop_Check(obj))
                return boolop_validate(obj);
        if (operator_Check(obj))
                return operator_validate(obj);
        if (unaryop_Check(obj))
                return unaryop_validate(obj);
        if (cmpop_Check(obj))
                return cmpop_validate(obj);
        if (comprehension_Check(obj))
                return comprehension_validate(obj);
        if (excepthandler_Check(obj))
                return excepthandler_validate(obj);
        if (arguments_Check(obj))
                return arguments_validate(obj);
        if (keyword_Check(obj))
                return keyword_validate(obj);
        if (alias_Check(obj))
                return alias_validate(obj);
        PyErr_Format(PyExc_TypeError, "Not an AST node: %s",
                     obj->ob_type->tp_name);
        return -1;
}


void init_ast(void)
{
        if (PyType_Ready(&Py_mod_Type) < 0)
                return;
        Py_Module_Type.tp_base = &Py_mod_Type;
        if (PyType_Ready(&Py_Module_Type) < 0)
                return;
        Py_Interactive_Type.tp_base = &Py_mod_Type;
        if (PyType_Ready(&Py_Interactive_Type) < 0)
                return;
        Py_Expression_Type.tp_base = &Py_mod_Type;
        if (PyType_Ready(&Py_Expression_Type) < 0)
                return;
        Py_Suite_Type.tp_base = &Py_mod_Type;
        if (PyType_Ready(&Py_Suite_Type) < 0)
                return;
        if (PyType_Ready(&Py_stmt_Type) < 0)
                return;
        Py_FunctionDef_Type.tp_base = &Py_stmt_Type;
        if (PyType_Ready(&Py_FunctionDef_Type) < 0)
                return;
        Py_ClassDef_Type.tp_base = &Py_stmt_Type;
        if (PyType_Ready(&Py_ClassDef_Type) < 0)
                return;
        Py_Return_Type.tp_base = &Py_stmt_Type;
        if (PyType_Ready(&Py_Return_Type) < 0)
                return;
        Py_Delete_Type.tp_base = &Py_stmt_Type;
        if (PyType_Ready(&Py_Delete_Type) < 0)
                return;
        Py_Assign_Type.tp_base = &Py_stmt_Type;
        if (PyType_Ready(&Py_Assign_Type) < 0)
                return;
        Py_AugAssign_Type.tp_base = &Py_stmt_Type;
        if (PyType_Ready(&Py_AugAssign_Type) < 0)
                return;
        Py_Print_Type.tp_base = &Py_stmt_Type;
        if (PyType_Ready(&Py_Print_Type) < 0)
                return;
        Py_For_Type.tp_base = &Py_stmt_Type;
        if (PyType_Ready(&Py_For_Type) < 0)
                return;
        Py_While_Type.tp_base = &Py_stmt_Type;
        if (PyType_Ready(&Py_While_Type) < 0)
                return;
        Py_If_Type.tp_base = &Py_stmt_Type;
        if (PyType_Ready(&Py_If_Type) < 0)
                return;
        Py_Raise_Type.tp_base = &Py_stmt_Type;
        if (PyType_Ready(&Py_Raise_Type) < 0)
                return;
        Py_TryExcept_Type.tp_base = &Py_stmt_Type;
        if (PyType_Ready(&Py_TryExcept_Type) < 0)
                return;
        Py_TryFinally_Type.tp_base = &Py_stmt_Type;
        if (PyType_Ready(&Py_TryFinally_Type) < 0)
                return;
        Py_Assert_Type.tp_base = &Py_stmt_Type;
        if (PyType_Ready(&Py_Assert_Type) < 0)
                return;
        Py_Import_Type.tp_base = &Py_stmt_Type;
        if (PyType_Ready(&Py_Import_Type) < 0)
                return;
        Py_ImportFrom_Type.tp_base = &Py_stmt_Type;
        if (PyType_Ready(&Py_ImportFrom_Type) < 0)
                return;
        Py_Exec_Type.tp_base = &Py_stmt_Type;
        if (PyType_Ready(&Py_Exec_Type) < 0)
                return;
        Py_Global_Type.tp_base = &Py_stmt_Type;
        if (PyType_Ready(&Py_Global_Type) < 0)
                return;
        Py_Expr_Type.tp_base = &Py_stmt_Type;
        if (PyType_Ready(&Py_Expr_Type) < 0)
                return;
        Py_Pass_Type.tp_base = &Py_stmt_Type;
        if (PyType_Ready(&Py_Pass_Type) < 0)
                return;
        Py_Break_Type.tp_base = &Py_stmt_Type;
        if (PyType_Ready(&Py_Break_Type) < 0)
                return;
        Py_Continue_Type.tp_base = &Py_stmt_Type;
        if (PyType_Ready(&Py_Continue_Type) < 0)
                return;
        if (PyType_Ready(&Py_expr_Type) < 0)
                return;
        Py_BoolOp_Type.tp_base = &Py_expr_Type;
        if (PyType_Ready(&Py_BoolOp_Type) < 0)
                return;
        Py_BinOp_Type.tp_base = &Py_expr_Type;
        if (PyType_Ready(&Py_BinOp_Type) < 0)
                return;
        Py_UnaryOp_Type.tp_base = &Py_expr_Type;
        if (PyType_Ready(&Py_UnaryOp_Type) < 0)
                return;
        Py_Lambda_Type.tp_base = &Py_expr_Type;
        if (PyType_Ready(&Py_Lambda_Type) < 0)
                return;
        Py_Dict_Type.tp_base = &Py_expr_Type;
        if (PyType_Ready(&Py_Dict_Type) < 0)
                return;
        Py_ListComp_Type.tp_base = &Py_expr_Type;
        if (PyType_Ready(&Py_ListComp_Type) < 0)
                return;
        Py_GeneratorExp_Type.tp_base = &Py_expr_Type;
        if (PyType_Ready(&Py_GeneratorExp_Type) < 0)
                return;
        Py_Yield_Type.tp_base = &Py_expr_Type;
        if (PyType_Ready(&Py_Yield_Type) < 0)
                return;
        Py_Compare_Type.tp_base = &Py_expr_Type;
        if (PyType_Ready(&Py_Compare_Type) < 0)
                return;
        Py_Call_Type.tp_base = &Py_expr_Type;
        if (PyType_Ready(&Py_Call_Type) < 0)
                return;
        Py_Repr_Type.tp_base = &Py_expr_Type;
        if (PyType_Ready(&Py_Repr_Type) < 0)
                return;
        Py_Num_Type.tp_base = &Py_expr_Type;
        if (PyType_Ready(&Py_Num_Type) < 0)
                return;
        Py_Str_Type.tp_base = &Py_expr_Type;
        if (PyType_Ready(&Py_Str_Type) < 0)
                return;
        Py_Attribute_Type.tp_base = &Py_expr_Type;
        if (PyType_Ready(&Py_Attribute_Type) < 0)
                return;
        Py_Subscript_Type.tp_base = &Py_expr_Type;
        if (PyType_Ready(&Py_Subscript_Type) < 0)
                return;
        Py_Name_Type.tp_base = &Py_expr_Type;
        if (PyType_Ready(&Py_Name_Type) < 0)
                return;
        Py_List_Type.tp_base = &Py_expr_Type;
        if (PyType_Ready(&Py_List_Type) < 0)
                return;
        Py_Tuple_Type.tp_base = &Py_expr_Type;
        if (PyType_Ready(&Py_Tuple_Type) < 0)
                return;
        if (PyType_Ready(&Py_expr_context_Type) < 0)
                return;
        Py_Load_Type.tp_base = &Py_expr_context_Type;
        if (PyType_Ready(&Py_Load_Type) < 0)
                return;
        Py_Store_Type.tp_base = &Py_expr_context_Type;
        if (PyType_Ready(&Py_Store_Type) < 0)
                return;
        Py_Del_Type.tp_base = &Py_expr_context_Type;
        if (PyType_Ready(&Py_Del_Type) < 0)
                return;
        Py_AugLoad_Type.tp_base = &Py_expr_context_Type;
        if (PyType_Ready(&Py_AugLoad_Type) < 0)
                return;
        Py_AugStore_Type.tp_base = &Py_expr_context_Type;
        if (PyType_Ready(&Py_AugStore_Type) < 0)
                return;
        Py_Param_Type.tp_base = &Py_expr_context_Type;
        if (PyType_Ready(&Py_Param_Type) < 0)
                return;
        if (PyType_Ready(&Py_slice_Type) < 0)
                return;
        Py_Ellipsis_Type.tp_base = &Py_slice_Type;
        if (PyType_Ready(&Py_Ellipsis_Type) < 0)
                return;
        Py_Slice_Type.tp_base = &Py_slice_Type;
        if (PyType_Ready(&Py_Slice_Type) < 0)
                return;
        Py_ExtSlice_Type.tp_base = &Py_slice_Type;
        if (PyType_Ready(&Py_ExtSlice_Type) < 0)
                return;
        Py_Index_Type.tp_base = &Py_slice_Type;
        if (PyType_Ready(&Py_Index_Type) < 0)
                return;
        if (PyType_Ready(&Py_boolop_Type) < 0)
                return;
        Py_And_Type.tp_base = &Py_boolop_Type;
        if (PyType_Ready(&Py_And_Type) < 0)
                return;
        Py_Or_Type.tp_base = &Py_boolop_Type;
        if (PyType_Ready(&Py_Or_Type) < 0)
                return;
        if (PyType_Ready(&Py_operator_Type) < 0)
                return;
        Py_Add_Type.tp_base = &Py_operator_Type;
        if (PyType_Ready(&Py_Add_Type) < 0)
                return;
        Py_Sub_Type.tp_base = &Py_operator_Type;
        if (PyType_Ready(&Py_Sub_Type) < 0)
                return;
        Py_Mult_Type.tp_base = &Py_operator_Type;
        if (PyType_Ready(&Py_Mult_Type) < 0)
                return;
        Py_Div_Type.tp_base = &Py_operator_Type;
        if (PyType_Ready(&Py_Div_Type) < 0)
                return;
        Py_Mod_Type.tp_base = &Py_operator_Type;
        if (PyType_Ready(&Py_Mod_Type) < 0)
                return;
        Py_Pow_Type.tp_base = &Py_operator_Type;
        if (PyType_Ready(&Py_Pow_Type) < 0)
                return;
        Py_LShift_Type.tp_base = &Py_operator_Type;
        if (PyType_Ready(&Py_LShift_Type) < 0)
                return;
        Py_RShift_Type.tp_base = &Py_operator_Type;
        if (PyType_Ready(&Py_RShift_Type) < 0)
                return;
        Py_BitOr_Type.tp_base = &Py_operator_Type;
        if (PyType_Ready(&Py_BitOr_Type) < 0)
                return;
        Py_BitXor_Type.tp_base = &Py_operator_Type;
        if (PyType_Ready(&Py_BitXor_Type) < 0)
                return;
        Py_BitAnd_Type.tp_base = &Py_operator_Type;
        if (PyType_Ready(&Py_BitAnd_Type) < 0)
                return;
        Py_FloorDiv_Type.tp_base = &Py_operator_Type;
        if (PyType_Ready(&Py_FloorDiv_Type) < 0)
                return;
        if (PyType_Ready(&Py_unaryop_Type) < 0)
                return;
        Py_Invert_Type.tp_base = &Py_unaryop_Type;
        if (PyType_Ready(&Py_Invert_Type) < 0)
                return;
        Py_Not_Type.tp_base = &Py_unaryop_Type;
        if (PyType_Ready(&Py_Not_Type) < 0)
                return;
        Py_UAdd_Type.tp_base = &Py_unaryop_Type;
        if (PyType_Ready(&Py_UAdd_Type) < 0)
                return;
        Py_USub_Type.tp_base = &Py_unaryop_Type;
        if (PyType_Ready(&Py_USub_Type) < 0)
                return;
        if (PyType_Ready(&Py_cmpop_Type) < 0)
                return;
        Py_Eq_Type.tp_base = &Py_cmpop_Type;
        if (PyType_Ready(&Py_Eq_Type) < 0)
                return;
        Py_NotEq_Type.tp_base = &Py_cmpop_Type;
        if (PyType_Ready(&Py_NotEq_Type) < 0)
                return;
        Py_Lt_Type.tp_base = &Py_cmpop_Type;
        if (PyType_Ready(&Py_Lt_Type) < 0)
                return;
        Py_LtE_Type.tp_base = &Py_cmpop_Type;
        if (PyType_Ready(&Py_LtE_Type) < 0)
                return;
        Py_Gt_Type.tp_base = &Py_cmpop_Type;
        if (PyType_Ready(&Py_Gt_Type) < 0)
                return;
        Py_GtE_Type.tp_base = &Py_cmpop_Type;
        if (PyType_Ready(&Py_GtE_Type) < 0)
                return;
        Py_Is_Type.tp_base = &Py_cmpop_Type;
        if (PyType_Ready(&Py_Is_Type) < 0)
                return;
        Py_IsNot_Type.tp_base = &Py_cmpop_Type;
        if (PyType_Ready(&Py_IsNot_Type) < 0)
                return;
        Py_In_Type.tp_base = &Py_cmpop_Type;
        if (PyType_Ready(&Py_In_Type) < 0)
                return;
        Py_NotIn_Type.tp_base = &Py_cmpop_Type;
        if (PyType_Ready(&Py_NotIn_Type) < 0)
                return;
        if (PyType_Ready(&Py_comprehension_Type) < 0)
                return;
        if (PyType_Ready(&Py_excepthandler_Type) < 0)
                return;
        if (PyType_Ready(&Py_arguments_Type) < 0)
                return;
        if (PyType_Ready(&Py_keyword_Type) < 0)
                return;
        if (PyType_Ready(&Py_alias_Type) < 0)
                return;
}

